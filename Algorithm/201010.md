## 알고리즘 - 모노미노도미노(2) :star:

 #### 소스코드 크기를 절반으로 줄였지만, 시간은 절약이 안된다.

 1. 어떤 블록을 맨 밑으로 내리는 행위를 모듈 개념으로 외워두자.

 ```
 void go(int type, int x, int y){
     // 단, 원본 블록은 0으로 없애주고 시작하자.
     int i; // 중요
     if(type == 1){
         for(i = 0; i < 6; i++){
             if(map[i][y] != 0) break;
         }
         map[i-1][y] = block;
     } else if(type == 2){
         for(i = 0; i < 6; i++){
             if(map[i][y] != 0 || map[i][y+1] != 0) break;
         }
         map[i-1][y] = block;
         map[i-1][y+1] = block;
     } else {
         for(i = 1; i < 6; i++){
             if(map[i][y] != 0) break;
             map[i-1][y] = block;
             map[i-2][y] = block;
         }
     }
 }
 ```

 2. 테트리스 후 윗줄 블록이 떨어질 때, 우수수 떨어지는 것이 아니라 블록 단위로 떨어짐을 코딩할 때

 ```
        // 테트리스 윗줄부터 거꾸로 접근하며
 		for (int k = i; k >= 0; k--) { // ↑ 방향
			for (int x = 0; x < 4; x++) { // → 방향이므로
                // 해당 블록이 0이 아니다(블록이 있다면)
				if (va[k][x] != 0) {
					int color = va[k][x];
                    // 3번 타입의 블록이라면
                    ■
                    ■
                    // ↑, → 방향으로 확인하고 있으므로 (for문 방향에 따라 확인하는 방향도 달라짐)
                    // va[k][x] == va[k+1][x]인지 확인할 필요가 없다.
					if (va[k - 1][x] == va[k][x]) {
						va[k - 1][x] = 0;
						va[k][x] = 0;
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0) break;
						}
						va[i - 1][x] = color;
						va[i - 2][x] = color;
					}
                    // 2번 타입 블록 ( ■ ■ )
					else if (va[k][x + 1] == va[k][x]) {
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0 || va[i][x + 1] != 0) break;
						}
						va[i - 1][x] = color;
						va[i - 1][x + 1] = color;

						va[k][x + 1] = 0;
						va[k][x] = 0;
					}
					else { // 1번 타입 블록 (■)
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0) break;
						}
						va[i - 1][x] = color;
						va[k][x] = 0;
					}
				}
			}
		}
```

3. 테트리스 되는 Action 후, 나머지 블록들이 떨어지고 다시 테트리스가 될 수 있음을 인지해라.

 - 어떤 문제를 풀던 간에 Action이 계속 될 수 있는 구조인지 반드시 판단하며 코딩할것.


## 알고리즘 - 스타트 택시(2)

 - 이 문제의 정답이 낮은 이유는 각 Action에서 발생할 수 있는 예외상황을 캐치하며 코딩하는가? 이다.

 1. Action 1 : { 택시가 거리 → 행 번호 → 열 번호 } 순으로 체킹하여 가야 하는 손님의 리스트를 확인

  - ※ 주의사항 ※
  - Q. 갈 수 없는 경우를 고려할 수 있는가?
  - 이때, 택시와 손님의 거릿값이 0으로 측정될 수 있다. 그래서 초기 check 값을 0이 아닌 -1로 받아야 하는 점. 이때, 소팅 범위에 포함되지 않게 커팅하는 능력이 매우 매우 중요하다.

 2. Action 2 : 택시에 탄 승객이 목적지 까지 감
  - ※ 주의사항 ※
  - 이 역시도 갈 수 없는 경우를 고려할 수 있는가?

 3. 목적지에 간 택시가 다음 승객을 태우는 과정

  - ※ 주의사항 ※
  - 이때, ★ Map에 있는 Object 끼리 겹칠 수 있는지에 대한 여부를 반드시 확인 해야 한다. ★

  - 문제가 주어지면 카르노맵을 그려 각 Object 끼리 겹칠 수 있는지에 대한 여부를 반드시 확인해라..

  - **:star: 문제를 읽으며 캐치하는 Action 별로 빈 종이에 설계를 한번 해 보고, 요구사항을 명확히 정의하고, State Check를 명확히 하고 코딩에 들어가야 한다. :star:**

 - **OOP 비슷하게 코딩하는 능력이 중요하다. Map에 Object 번호만 넣어두는 방식은, Map에 여러 Object가 겹치는 경우 해결하기 힘든 단점이 있다. 그래서, 겹칠 수 있는지 여부를 판단하고 OOP 위주로 할지, Map 위주로 할 지 결정해라.**

 ## 알고리즘 - 어른 상어(2)

  - **문제를 읽고 내가 이해한 로직대로 예시가 흘러가는지 반드시 확인하며 코딩에 들어가야 함을 느낀 문제이다.**

  - 각 상어의 우선순위 좌푯값들을 구조체에 배열로 넣어두고, 이를 끌어다가 쓸 줄 아는 능력이 중요했다.

  - 여기선 어떤 Object가 **소멸**될 수 있는 상황이기 때문에, Object Search 할 때 if(Obj == 죽음) continue; 하는 습관이 반드시 되어 있어야 한다.

  - **★★★ 맵의 한 칸에 여러 Object 들이 겹치고 여기서 로직처리 하여 한 Object만 뽑아내고, 나머진 없애야 하는 경우 ★★★**

  - OOP 위주로 할때, 이동할 수 있는 로직이 통과되고 이동이 되는 부분에서 반드시 각 Obj의 프로퍼티 값을 모두 체킹해야 한다는 강박관념을 가지자.
  - 바라보는 방향 값 갱신 하지 않아서 고생함..

  - 그리고 한번 갔다면 break로 끊어 주는 버릇도 가져야 한다.

```
 1. 이동할 수 있는 다음 좌표를 임시 맵인 tmap에 넣는다.

 2. tmap에서 로직 수행을 한다.

 3. 이 tmap을 원본 map에 넣는다.

 4. tmap은 반드시 memset 된 상태에서 수행해야 한다.
```

 - 위 로직은 [원자 소멸 시뮬레이션], [나무 재테크], [낚시왕] 등 다양한 문제에서 사용되니까 다시 풀어서 반드시 빠른 시간을 확보하자.

## 알고리즘 - 나무 재테크(3)

 1. tree List (vector)와 tree[x][y] (vector) 자료구조 간 오브젝트 관리법을 익혔다.

  - 두개 자료구조는 삭제를 위해 반드시 Object id가 필요하다.

 2. **vector<int> tree[i][j] 간 로직 정리를 할 때, 살아있는 Object만 따로 정리하는 방법은 시간에 아주 큰 영향을 준다. 살아있는 Obj만 남기는 방법이 있을까? 에 대해 생각을 해야 한다.**

 3. tree를 순회한다는 것은 각 Object가 한번씩만 조회됨이 보장이 되어야 한다. 그래서, tree → tree[x][y](vector)로 접근하는 로직의 경우, tree가 두번 이상 조회되거나 삽입, 삭제가 될 가능성이 있으므로, set으로 관리를 해줘야 한다. 단, 이러면 시간초과가 될 가능성은 있다.

## 알고리즘 - 낚시왕(3)

 - Object 중첩 관리할때 나만의 원칙을 만듦.

#### Object 중첩 이슈 처리 나만의 로직. 계속 익혀라!

 1. shark 구조체를 만들어 관리. 이때 id값 필수

 2. int map[105][105]는 shark의 number만 가지고 있자.

 3. 중첩 이슈는 {중첩에 필요한 값, id} 매핑하여 벡터로 tmap 처럼 가지고 있는다.

  - tmap에 다음 좌푯값의 id를 넣어놓는다.

  - 구조체의 x,y,d 좌표를 최신화한다. (★d좌표 최신화 필수 자주 실수한다★)

  - 한번 더 돌면서 중첩이슈 처리 하고, 이슈에 살아남은 벡터(live)를 클린하게 따로 관리한다.

  - 기존 구조체의 좌표를 -1로 초기화 하자(무결성 보장을 위해)

  - live 벡터를 돌며 살아남은 물고기 넘버를 구조체에 최신화시키자.

## 알고리즘 - 원자 소멸 시뮬레이션(3)

 - vector<int> tmap[4005][4005] 선언하자마자 터지는 기적을 예방하기 위해

 - 두 원자가 겹치는 경우 로직을 처리하는 간단하면서 다른 방법에 대해 알아보자.

 ```

 1. 단순히 map[x][y]엔 Object 개수를 넣는다. Object를 순회하며 map[x][y]++를 해준다.

 2. Object list를 O(n^2)으로 순회한다. 즉, if(map[x][y] > 2) 라면

  - 이때 한번 더 for(Object List)를 하여 if(x == Obj[i].x && y == Obj[i].y)라면 이 Object를 죽이고 답을 출력한다.

  - Obj List를 순회하였다면 해당 map[x][y] = 0으로 해준다.

```



 ## 20. 10. 10(토)
  - 코딩의 귀신이 되자
  - 위에서 언급한 습관들을 항상 생각하며, 예외 상황이 없게 코딩하는 능력이 매우매우 중요하다.

  - Obj 중첩 시 Runtime err 날 것 같으면 원자 소멸과 같은 방법으로, n과 Obj가 매우 작다면 낚시왕과 같은 로직으로 돌려도 될 것 같다. 하지만 다른사람들은 어떻게 중첩 이슈를 관리했는지 반드시 보고 효율적인 방법을 익혀야 한다..
  
