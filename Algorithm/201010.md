## 알고리즘 - 모노미노도미노(2) :star:

 #### 소스코드 크기를 절반으로 줄였지만, 시간은 절약이 안된다.

 1. 어떤 블록을 맨 밑으로 내리는 행위를 모듈 개념으로 외워두자.

 ```
 void go(int type, int x, int y){
     // 단, 원본 블록은 0으로 없애주고 시작하자.
     int i; // 중요
     if(type == 1){
         for(i = 0; i < 6; i++){
             if(map[i][y] != 0) break;
         }
         map[i-1][y] = block;
     } else if(type == 2){
         for(i = 0; i < 6; i++){
             if(map[i][y] != 0 || map[i][y+1] != 0) break;
         }
         map[i-1][y] = block;
         map[i-1][y+1] = block;
     } else {
         for(i = 1; i < 6; i++){
             if(map[i][y] != 0) break;
             map[i-1][y] = block;
             map[i-2][y] = block;
         }
     }
 }
 ```

 2. 테트리스 후 윗줄 블록이 떨어질 때, 우수수 떨어지는 것이 아니라 블록 단위로 떨어짐을 코딩할 때

 ```
        // 테트리스 윗줄부터 거꾸로 접근하며
 		for (int k = i; k >= 0; k--) { // ↑ 방향
			for (int x = 0; x < 4; x++) { // → 방향이므로
                // 해당 블록이 0이 아니다(블록이 있다면)
				if (va[k][x] != 0) {
					int color = va[k][x];
                    // 3번 타입의 블록이라면
                    ■
                    ■
                    // ↑, → 방향으로 확인하고 있으므로 (for문 방향에 따라 확인하는 방향도 달라짐)
                    // va[k][x] == va[k+1][x]인지 확인할 필요가 없다.
					if (va[k - 1][x] == va[k][x]) {
						va[k - 1][x] = 0;
						va[k][x] = 0;
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0) break;
						}
						va[i - 1][x] = color;
						va[i - 2][x] = color;
					}
                    // 2번 타입 블록 ( ■ ■ )
					else if (va[k][x + 1] == va[k][x]) {
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0 || va[i][x + 1] != 0) break;
						}
						va[i - 1][x] = color;
						va[i - 1][x + 1] = color;

						va[k][x + 1] = 0;
						va[k][x] = 0;
					}
					else { // 1번 타입 블록 (■)
						for (i = k+1; i < 6; i++) {
							if (va[i][x] != 0) break;
						}
						va[i - 1][x] = color;
						va[k][x] = 0;
					}
				}
			}
		}
```

3. 테트리스 되는 Action 후, 나머지 블록들이 떨어지고 다시 테트리스가 될 수 있음을 인지해라.

 - 어떤 문제를 풀던 간에 Action이 계속 될 수 있는 구조인지 반드시 판단하며 코딩할것.


## 알고리즘 - 스타트 택시(2)

 - 이 문제의 정답이 낮은 이유는 각 Action에서 발생할 수 있는 예외상황을 캐치하며 코딩하는가? 이다.

 1. Action 1 : { 택시가 거리 → 행 번호 → 열 번호 } 순으로 체킹하여 가야 하는 손님의 리스트를 확인

  - ※ 주의사항 ※
  - Q. 갈 수 없는 경우를 고려할 수 있는가?
  - 이때, 택시와 손님의 거릿값이 0으로 측정될 수 있다. 그래서 초기 check 값을 0이 아닌 -1로 받아야 하는 점. 이때, 소팅 범위에 포함되지 않게 커팅하는 능력이 매우 매우 중요하다.

 2. Action 2 : 택시에 탄 승객이 목적지 까지 감
  - ※ 주의사항 ※
  - 이 역시도 갈 수 없는 경우를 고려할 수 있는가?

 3. 목적지에 간 택시가 다음 승객을 태우는 과정

  - ※ 주의사항 ※
  - 이때, ★ Map에 있는 Object 끼리 겹칠 수 있는지에 대한 여부를 반드시 확인 해야 한다. ★

  - 문제가 주어지면 카르노맵을 그려 각 Object 끼리 겹칠 수 있는지에 대한 여부를 반드시 확인해라..

  - **:star: 문제를 읽으며 캐치하는 Action 별로 빈 종이에 설계를 한번 해 보고, 요구사항을 명확히 정의하고, State Check를 명확히 하고 코딩에 들어가야 한다. :star:**

 - **OOP 비슷하게 코딩하는 능력이 중요하다. Map에 Object 번호만 넣어두는 방식은, Map에 여러 Object가 겹치는 경우 해결하기 힘든 단점이 있다. 그래서, 겹칠 수 있는지 여부를 판단하고 OOP 위주로 할지, Map 위주로 할 지 결정해라.**

 ## 알고리즘 - 어른 상어(2)

  - **문제를 읽고 내가 이해한 로직대로 예시가 흘러가는지 반드시 확인하며 코딩에 들어가야 함을 느낀 문제이다.**

  - 각 상어의 우선순위 좌푯값들을 구조체에 배열로 넣어두고, 이를 끌어다가 쓸 줄 아는 능력이 중요했다.

  - 여기선 어떤 Object가 **소멸**될 수 있는 상황이기 때문에, Object Search 할 때 if(Obj == 죽음) continue; 하는 습관이 반드시 되어 있어야 한다.

  - **★★★ 맵의 한 칸에 여러 Object 들이 겹치고 여기서 로직처리 하여 한 Object만 뽑아내고, 나머진 없애야 하는 경우 ★★★**

  - OOP 위주로 할때, 이동할 수 있는 로직이 통과되고 이동이 되는 부분에서 반드시 각 Obj의 프로퍼티 값을 모두 체킹해야 한다는 강박관념을 가지자.
  - 바라보는 방향 값 갱신 하지 않아서 고생함..

  - 그리고 한번 갔다면 break로 끊어 주는 버릇도 가져야 한다.

```
 1. 이동할 수 있는 다음 좌표를 임시 맵인 tmap에 넣는다.

 2. tmap에서 로직 수행을 한다.

 3. 이 tmap을 원본 map에 넣는다.

 4. tmap은 반드시 memset 된 상태에서 수행해야 한다.
```

 - 위 로직은 [원자 소멸 시뮬레이션], [나무 자르기], [낚시왕] 등 다양한 문제에서 사용되니까 다시 풀어서 반드시 빠른 시간을 확보하자.


 ## 20. 10. 10(토)
  - 코딩의 귀신이 되자
  - 위에서 언급한 습관들을 항상 생각하며, 예외 상황이 없게 코딩하는 능력이 매우매우 중요하다.
  