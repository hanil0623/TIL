## 알고리즘 - 최솟값 찾기 :airplane:

 - 어떤 수열에서 연속된 특정 구간의 최솟값을 O(n)만에 찾는 방법이다.

 - n이 5,000,000이기에 세그먼트 트리인 nlogn도 통하지 않는다.

LOGIC
```
// dq엔 수열의 인덱스만 저장한다.

	for (i = 1; i <= n; i++) {
        // 1. 원소를 하나 받는다.
		cin >> a[i];
        // 2. dq가 비지 않았으면서 원소가 기존의 dq에 있는 원소값보다 같거나 작다면
		while (!dq.empty() && a[dq.back()] >= a[i]) {
            // 3. 모두 pop을 해준다. 
            (같거나 작은 원소가 새로 들어오는 순간, 기존의 원소들은 최솟값의 후보군에서 제외되기 때문)
			dq.pop_back();
		}
        // 3. 모두 제거했으면 원소 번호를 넣는다.
		dq.push_back(i);

        // 4. dq의 앞쪽 원소 번호가 i-k 즉 구간의 길이에 해당하지 않는다면
		if (dq.front() <= i - k) {
            // 5. 이 원소는 제거해 준다.
			dq.pop_front();
		}
        // 6. 구간의 최솟값은 dq의 앞쪽 원소를 보면 된다.
		cout << a[dq.front()] << ' ';
	}
```

## 20. 08. 31(월)
 - 처음 볼때 푸는 것이 거의 불가능한 문제지만 아는 것이 힘이다. 더 노력하자!
 - **All solve!** :happy_face: