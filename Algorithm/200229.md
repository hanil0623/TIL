## 알고리즘 - 프로세서 연결하기
 - 문제점 : Core 개수, 연결 개수의 두가지 항목을 따질 때, Core의 개수가 많은 것을 우선적으로 하는 경우
    : 해결 1. PQ를 사용하여 Core 개수는 +로, 연결 길이는 -로 하여 답은 도출 할 수 있었으나, TLE가 떴다.
    
    : 해결 2. 그럼, 수동으로 구현해줘야한다.
     ```
     if (chk == vsize) {
		if (maxcore < core) { // 코어 개수가 큰 경우
			maxcore = core; // 코어 개수 업데이트와
			minsum = sum; // 선 길이 둘 다 업데이트.
		}
		else if (maxcore == core) {
			minsum = min(minsum, sum); 
            // 같으면 선 길이만 업데이트.
		}
		return;
	}
    ```

49번에서 막힐경우
---------------------
결과값을 뽑을때
코어 최대 갯수가 2개
전선 최소 개수가 4개 일떄

코어 최대 개수가 3개
전선 최대 개수가 6개가 들어오면

바꿔줘야하는데 코어개수는 맞으나 전선개수가 더적기 떄문에 안바꿔지는 경우가 있었습니다.
그래서 코어 갯수가 같은 경우와 코어갯수가 더클경우로 나눠서
코어갯수가 같으면 전선갯수가 더 작은것 저장
코어 갯수가 더 클경우 기존의 전선개수 초기화시키고 새로운 전선개수 저장 해줘야되는듯합니다..

 - Tip 1 : dfs를 활용한 벡터를 사용 시, 기존 개수보다 +1 된 벡터를 push_back을 시켜주자. 단, v.size() 하기 전 저장하는 것 잊지 말고
 - Tip 2 : 네 방향 모두 조건을 통과하지 못할 시, 한 방향만 검사하는 용도의 flag, 네 방향 검사용인 dircnt를 쓰는 버릇 들이자.

위 말대로, 코어 개수가 많을 수록 전선 개수도 업데이트 되어야 한다.

***반례를 만들 때 생각해 봐야 하는 점***
 - 1. 한쪽으로 선을 연결해야 dfs가 적용되는 경우라면?
    : 모든 방향으로 가지치기가 되지 않을때 처리는?

 - 2. 벽인 경우는? 또다른 코어인 경우는? 선인 경우는?
    : 모든 경우를 다 나눠서 처리하는 습관 가지자.

## 20. 02. 29(토)
 - 집에 있으니 나태해졌다. 다시 버닝 하기 D-7!