## 알고리즘 - 기능 개발

 1. 하루마다 할 수 있는 일의 양, (time) 100% 시 완료.(완료조건)

 2. 단, 완료한다고 출시하는 것이 아님. ***선수조건***이 있다.

 3. 선수조건을 어떻게 큐로 표현할 수 있는가?

    - 100 - prosses[i] / day[i]를 하면 남은 일을 몇일 만에 할 수 있는가? 가 나온다.
    - 만약 나머지가 1 이상이라면, +1일을 해 줘야 완벽하게 처리할 수 있다. 아니라면 바로 나누면 됨.
    - 즉, 큐에는 ***선수 개발 순위별 남아있는 날짜***를 넣는다.

    ```
    int bound = q.front();
    while(!q.empty()){
        if(q.front() <= bound)
        {
            // 6 3 10 인 경우, 선수조건 때문에 3은 최소 6일이 지나야 앞 기능이
            // publish 되고 다음 것도 마찬가지다.
            cnt++;
            q.pop();
        }
        else{
            // 만약 10이 나온다면 최소 10일 조건을 바꿔주고
            // 답에 체크
            bound = q.front();
            answer.push_back(cnt);
            cnt = 0;
        }
    }
    ```

## 알고리즘 - 주식 가격

 1. O(n^2)이고 n이 10만이면 터질거라 생각했는데 막상 풀어보니 됬다.

  - 큐/스택으로 쓰라고 낸 문제이지만 스택으로 푸는게 쉽지 않은 문제.. 더 연습해야지

## 알고리즘 - 프린터

 1. 우선순위를 이미 알고있다면 매우 풀기 쉬운 문제가 되지.
  
  - 이를 위해 priority_queue가 사용된다. 아주아주 중요.

  - 이게 되면 나머진 구현의 문제이고 문제를 매우매우 잘 읽어야 한다.

  ```
  큐에는 {idx, prior}를 담고 pq에는 {prior}만 담으면 알아서 정렬됨.

  while(!q.empty()){
      int idx = q.front().first;
      int prior = q.front().second;
      q.pop();

      if(prior == pq.top()){
          // 출력하는 경우
          answer++;
          // 출력 후, pq값도 pop해줘야 새로운 우선순위가 바뀐다.
          pq.pop();
          // 지금 내가 뽑는 문서가 문제에서 요구하는 idx와 같다면 종료한다.
          if(location == idx) break;
      } else{
          // 아니라면 문제의 조건처럼 계속 큐에 넣어준다.
          q.push({idx, prior});
      }
  }
  ```

## 20. 06. 04(목)
 - 내일 코테~~ 함 해보자.
    