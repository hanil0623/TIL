## 알고리즘 - 시뮬레이션 설계(모노도노도미노)
 1. 설계를 한다는게 구체적인 코드를 짜라는 것이 아니고 대강 큰 틀을 잡으란 얘기다.
 여기서는 복잡한 구현이면서도 중복되는 내용이 있다면 이를 함수화 하여 표현하는 것이 필수라 할 수 있다.

  - 특정 Obj를 특정 방향으로 밀 수 있는가?
    + 잘못 밀면 값이 겹쳐서 오류날까봐 이 방법에 대한 확신이 없었다.

  - 마법의 공간에 Obj가 들어오면 삭제할 수 있는가?
    + 이건 할만하다. 그냥 지우면 된다.

  - 삭제 후 삭제한 idx의 최솟값을 기준으로 하여 Obj를 밀 수 있는가?
    + Obj를 민다. Obj 벡터 생성 후, 이를 미는 함수를 만들었으면 쉽겠지.. 아니 그냥 색종이 자체를 덧붙이는게 좋다.

  - 테트리스 후에는 색종이를 이어붙히면 안되고 남아있는 Obj 값들을 다 밀어넣는 함수를 만들어야 한다.

 2. 시뮬레이션 약하다. 클러스터 움직이는것이 나왔는데 이때 변수 관리가 제대로 되지 않았다.

  - 시뮬레이션은 평소 보드게임에서 자주 나오네. 이런 게임들 보면 원리를 알고 넘어가자.. 코드 뜯어보는 습관 중요하겠다.

  - 설계할때 큰 틀만 잡고 가자.. 세세한 조건 놓치지 말자는 의미임. 막코딩은 물론 좋지만 차선책으로 하고 되도록 함수로 끝내자는 느낌..

  ## 알고리즘 - 지형 이동
   1. 다리 만들기 2와 거의 흡사한 문제이다.
    - Kruskal을 이용하여 문제 풀 때, 섬 번호와 최소 거리를 저장하는 전처리 과정

    - 이를 바탕으로 union-find 하여 sort 후 값 도출 과정.

    - 여기서 중요한 점은 섬 간 번호와 거리를 모아둔 vector size만큼 돌아도 된다는 점.
     while(connect < nodesize - 1) 에 꼭 틀을 맞추지 않아도 어차피 if(getParent[u] == getParent[v]) continue;에서 걸러준다.


## 20. 06. 08(월)
 - 시뮬 약하다. 좋은 기회다. 설계 꼼꼼히 하고 모듈화하여 풀어보는 연습 자주 해라. 알고리즘이 아니고 구현력의 차이이다.