# 알고리즘 - 게리 맨더링 1
  ### 핵심 Problem
   - 1. 연결되어 있는 그래프에서 브루트 포스 형식으로 팀을 나누는 작업이 어려움 ★
      > Solve : 비트마스킹을 통해 쉽게 팀을 나누는 방법
      ```
      // 여기서 i는 1부터 63까지 돈다.
      // 00000001부터 n비트인 0111111까지 돈다.
      for(int i=1; i< 1 << N; i++){
          memset(check);
          sum = 0;
          // blue team 나누기
          for(int j=0; j<n; j++){
              if(i & (1 << j)){
                  sum = dfs(j+1, i);
                  break;
              }
          }
          // red team 나누기, 물결 표시를 이용하여 2개의 팀으로 나누려는 생각을 어떻게 했을까?
          for(int j=0; j<n; j++){
              if(~i & (1 << j)){
                  sum -= dfs(j+1, ~i);
                  break;
              }
          }
      }

      int dfs(int x, int bitmask){
          int res = map[x];
          check[x] = 1;
          for(int i=0; i<n; i++){
              if(adj[x][i+1] (인접해있는가?) && (bitmask & (1 << i))(우리편인가?) && !check[i+1](간적있냐?)){
                  // 이 모든 조건이 만족되면 해당 노드로 이동한다.
                  res += dfs(i+1, bitmask);
              }
          }
          return res;
      }
   - 2. dfs를 돌 때 핵심 조건 3가지를 이해했었는가? (위 코드에 있음)
   - 3. 완벽한 팀 구성이 되었는지 확인하는 방법으로 check가 되었으면서 n보다 큰지 조사했다. 그럴 경우에만 계산하였다.
   - 4. i = 1인데 ~i = -2라는 점.
        : 1은 0000000001인데 -1은 2의 보수방식(0과 1을 바꾼 후 +1을 하는 방식)으로 구한다. 
          이와 같이 2인 00000010을 -2로 2의 보수방식으로 해 보면, 111111110이 나와서 1을 틸트연산 한 효과와 같다는 점이다.

## 20. 01. 26(일)
 - 나태하다. 아직 간절하지 않아 보인다.
 - 알바 해서 내 자신을 찾은 것 같아 기쁘지만, 중심을 찾자

