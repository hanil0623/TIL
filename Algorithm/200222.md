## 알고리즘 - 부등호
 - 1. 모든 경우의 수로 순열을 구현할 수 있는가?

    ```
    dfs(int cnt){
        if(cnt > N){
            결과값
        }
        for(int i=0; i<N; i++){
            if(check[i]) continue;
            check[i] = i;
            chk.push_back(i);
            dfs(cnt+1);
            check[i] = 0;
            chk.pop_back();
        }
    }
    ```
 - 2. max, min 값을 찾는 과정에서 반드시 스트링 배열로 출력 + 10글자 = ?

 - 3. 첫 글자가 0인 경우엔 0을 표시해야만 했었다.
   = 0을 꼭 표시해야 하는데 대소관계를 비교해야 한다면 max, min 함수를 쓰지 말고
     vector<string> v; 를 만든 다음, 스트링 값을 하나씩 집어넣고, sorting을 하자.
     소팅 후 가장 앞에 있는건 최솟값, 뒤에 있는건 최댓값이겠지
   = 중요한 것은 string 배열 역시도 소팅이 된다는 점이다. 이렇게 할 수 있다면   
     상당히 편리해진다.

 - 4. 10글자는 98억까지 나타낼 수 있으므로, int의 max인 21억을 넘어서게 된다.
  - 그래서 string의 값을 int가 아닌 long long으로 바꿔야 하는데, 이때 쓰는 함수는
  - **stoull(s)**이다.

 - 5. int를 char로 바꿀 때 왜 i + '0'을 하는가?
  - int의 1과 char의 '1'은 컴퓨터가 받아들이기에 다르게 받아들인다.
  - int는 단순 정수를 나타내는 것이고, char은 아스키코드표를 기준으로 받아들인다.
  - 따라서, '1'은 아스키코드표에서 49번이므로, 1번의 int형 1 + '0'(48) = 49가 된다.
  - i + 48을 하는 사람도 있다.

### 잡지식 - 깊은 복사와 얕은 복사
 - 깊은 복사(Deep Copy)는 어떤 객체를 복사할 때 객체 안에 참조형 변수(포인터형 변수)가 있다고 하면, **참조형 변수의 공간을 따로 만들어 그 값을 복사**하는 형태이다.

 - 얕은 복사(Shallow copy)는 **참조형 변수의 공간을 따로 만들지 않고, 공유**하는 형태이다. 따라서 이 내용이 나중에 바뀌게 된다면 참조하는 모든 내용이 바뀌게 된다.

## 20. 02. 22(토)
 - string 값에 대한 연습을 할 수 있어서 좋았다.
 - string.push_back('255')는 들어가지 않는다. string에 값을 넣을 땐 
 - string.push_back("255")인 쌍따옴표로 넣어야 들어간다.
 - string.at(i)는 i번째 요소를 반환 // string.size()는 사이즈 반환.
