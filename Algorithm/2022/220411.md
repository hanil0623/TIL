## 알고리즘 - 사장님 달려가고 있습니다

 > 1. 상태변수를 설계할 수 있는 능력이 중요
  check[x][y][k][d] : x,y좌표로 오기까지 k칸을 거쳐오며, d방향에서 왔는가?


 > 2. k칸으로 한방에 이동한다는 생각 아래엔 항상 *탐색*개념이 들어간다. 즉, k칸을 순간이동하는것이 아니다. 반드시 갈수있는지 장애물 없는지 체킹해야한다.

 FULL CODE
 ```
 // 21'10
#define SHARK 77
#include<iostream>
#include<cassert>
#include<vector>
#include<cstring>
using namespace std;
int res;
int dx[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
int dy[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };

struct info {
	int x, y, d;
	bool live;
};

info lst[17];

int map[4][4];
int sx, sy, sd;

int EatFish(int x, int y) {
	int idx = map[x][y];

	if (idx == SHARK) {
		assert(0);
	}

	if (lst[idx].live == false) {
		assert(0);
	}
	else {
		map[sx][sy] = 0; // 상어가 있다 나온자리 0으로.
		map[x][y] = SHARK;
		sx = x;
		sy = y;
		sd = lst[idx].d;
		lst[idx].live = false;
	}
	return idx;
}

bool isEatFish(int x, int y) {
	// 살아있는 상어만 있음이 보장되는가.
	int sd = lst[map[x][y]].d;
	if (lst[map[x][y]].live == false) {
		assert(0);
	}

	// 상어가 애초에 죽은 상어에게만 갈리 없다.

	vector<pair<int, int>> plst;
	for (int i = 0; i < 3; i++) {
		int nx = x + dx[sd];
		int ny = y + dy[sd];
		if (nx < 0 || nx >= 4 || ny < 0 || ny >= 4) break;
		if (lst[map[nx][ny]].d == 0) break;
		plst.push_back({ nx, ny });
	}

	if (plst.size() > 0) {
		return true;
	}
	return false;
}


void swap_object(int sx, int sy, int ex, int ey, int nd) {
	int idx = map[sx][sy];
	int nidx = map[ex][ey];

	// 야. 만약 빈칸으로 이동하면 어쩔건데? 하.
	if (nidx == 0) {
		lst[idx].x = ex;
		lst[idx].y = ey;
		lst[idx].d = nd;
		map[ex][ey] = idx;
		map[sx][sy] = 0;
	}
	// 빈칸에 이동하는 경우와, Object를 swap하는경우 다르잖아 아.
	else {
		// 아,, object 교환 시 고려해야 하는것들 자꾸 실수하네?
		lst[idx].d = nd;
		swap(lst[idx].x, lst[nidx].x);
		swap(lst[idx].y, lst[nidx].y);
		swap(map[sx][sy], map[ex][ey]);
	}
}

void moveFish() {
	for (int i = 1; i <= 16; i++) {
		if (lst[i].live == false) continue; // 죽은 물고기는 이동하지 않음.
		
		int fd = lst[i].d;

		for (int j = 0; j < 8; j++) {
			int ndir = (fd + j) % 8;
			int nx = lst[i].x + dx[ndir];
			int ny = lst[i].y + dy[ndir];
			if (nx < 0 || nx >= 4 || ny < 0 || ny >= 4) continue;
			// 아 물고기 빈칸으로 이동할수있네 하 아 왜이런느데 자꾸.
			if (0 <= map[nx][ny] && map[nx][ny] <= 16) {
				swap_object(lst[i].x, lst[i].y, nx, ny, ndir);
				break;
			}
		}
	}
}

void moveShark(int x, int y, int sum) {
	//cout << "x : " << x << " y : " << y << "sum : " << sum << '\n';

	// 아, doing하는 시점을 내가 잘 모르는구나.
	moveFish();
	if (res < sum) {
		res = sum;
	}
	// 상태저장.
	info snapshot[17];
	int smap[4][4];
	int md = sd;
	memcpy(snapshot, lst, sizeof(snapshot));
	memcpy(smap, map, sizeof(map));

	
	//int sd = lst[map[x][y]].d;
	//if (lst[map[x][y]].live == false) {
		//assert(0);
	//}

	// 상어가 애초에 죽은 상어에게만 갈리 없다.

	vector<pair<int, int>> plst;

	// 여러번 이동할수있다는 말이 아.
	for (int i = 1; i <= 3; i++) {
		int nx = x + dx[sd]*i;
		int ny = y + dy[sd]*i;
		if (nx < 0 || nx >= 4 || ny < 0 || ny >= 4) break;
		if (lst[map[nx][ny]].live == false) {
			continue;
		}
		
		int point = EatFish(nx, ny);
		moveShark(nx, ny, sum + point);
		// 상태회복.
		memcpy(lst, snapshot, sizeof(snapshot));
		memcpy(map, smap, sizeof(map));
		sx = x;
		sy = y;
		sd = md;
	}
}
int main() {
	
	// 상어가 물고기를 먹는다. Obj 소멸.

	// 1. 상어가 물고기를 먹음. 상어방향 = 잡아먹힌 물고기의 방향

	// 2. 번호가 작은 물고기라, Obj 순회다.
	// 이동 전, 탐색행위를 한다. 있을때까지 방향 45도 반시계 회전.
	// 특이한게, 이동행위를 하면 보통 겹치는데, 이동 안에 당사자 물고기와 swap이 있다.
	// 한 instruction이 물고기 방향까지 바꾸는거란 말이지.?

	// 3. Obj가 이동하는데, "한번에 여러개의 칸을 이동함" 
	// 상어는 물고기 있는 칸으로 이동 가능함. 없으면 불가능.

	// 상어가 이동 불가능할때 dfs의 상태 전환이 끝나는구나.
	// 언제끝나? 상어가 이동불가능할때.

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			int a, b; cin >> a >> b;
			b--;
			lst[a] = { i, j, b, true };
			map[i][j] = a;
		}
	}

	int init = EatFish(sx, sy);
	moveShark(sx, sy, init);
	cout << res << '\n';
	/*
	while (1) {
		EatFish(sx, sy);
		moveFish();
		moveShark(sx, sy, 0);
		if (false == isEatFish(sx, sy)) break;
	}*/
	
	return 0;
}
```
## 22. 04. 11(월)

- 가장 차가울 2개월