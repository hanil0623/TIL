## 알고리즘 - 어항 정리

 1. 특정 조건을 만족시키는 어항(블럭, Group)만 **선별**한다.
    > 문제 변형 시, 충분히 선별에 관련된 문제가 나올 수 있음.

 2. 선별한 Group을 회전 및 변형을 하여 다른 곳으로 옮긴다.
    > 다른 곳으로 옮길 때, 규칙성을 발견할 수 있는가?

    ```
            1   2   3   4   5   6
    pivot   1   2   3   5   7   10
        w   1   1   2   2   3   3
        h   1   2   2   3   3   4
    ```

    > pivot += (doing/2) + 1;
    > doing % 2 == 0 ? h++ : w++;

 3. 물고기 수 조절 Event 처리
    :star: Tip : 물고기가 옆 칸보다 많을 경우만 처리해 주면 이벤트 겹칠 일이 없다.
        (많을 경우와 적을 경우를 모두 처리 시, 두번 중복 처리가 됨) 

 4. 규칙성을 발견해야만 하는 Object 변형 및 재이동 (순수 구현하려면 오래걸림)
    > case search를 통해 이런 이슈를 해결하는 방법도 있다.


### To-do List

move Obj   : ~~모노미노도미노~~, ~~배열 돌리기(2, 6)~~, 2048, 비바라기, 카탄의 개척자, 디저트 카페
select Obj : 상어 중학교, 약품 처리(dfs+bfs), Gaaarden

순간순간 dfs 쓰는 문제가 나올 수 있다는점.

## 알고리즘 - 어른 상어

 Point 1. bfs에서 check의 대원칙은 한번 지나간 블록은 다시 지나치지 않는다는 개념이다. check에는 무지개 블록과 일반 블록 모두 처리를 해주는데, visit 배열을 따로 만들어 무지개 블록만 따로 체킹을 하자.

  > 한 일반블록의 bfs가 끝난후, **visit 배열을 이용해 check 배열의 1을 0으로 초기화** 하자. visit은 check가 정상작동하기 위한 수단임. 일반블록 한번 후 -> 초기화 -> 다시 퍼짐.
  
## 알고리즘 - 모노미노도미노 2

 Point 1. 문제에서 테트리스 후 그 위에있는 블록들을 ~~빈공간이 없을때까지 떨어뜨리는 문제가 아니다~~ :star:

 Point 2. Object 이동 후(정확힌 영역 복사), 복사 이후 나머지 영역들을 모두 0으로 초기화해줘야 한다. 잦은 실수 조심!

## 22. 10. 04 (화)

 - 꾸준히 끝까지
