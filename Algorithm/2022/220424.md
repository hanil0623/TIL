## 알고리즘 - 벌꿀 채취

> 1. Group 2개 추출 → Group 내 최대 채취량 추출이 아니라

> 1. Group 하나 추출(deque)할때마다 최대 채취량 추출하여 vector에 저장 → 이후 filtering.

```
void collect_honey() {
	// dq로 두개의 group을 모으는 행위를 어떻게했더라.
	
	for (int i = 0; i < N; i++) {
		dq.clear();
		for (int j = 0; j < N; j++) {
			// sz가 m이 되는 모든 group의 최댓값 구하기
			dq.push_back(map[i][j]);
			if (dq.size() > M) dq.pop_front();
			if (dq.size() == M) {
				mx = 0;
				memset(check, 0, sizeof(check));
				f(0, 0, 0);
				// 그룹의 알짜 정보만 모아두고
				v.push_back({ i, j, mx });
			}
		}
	}
}

void f(int srt, int sum, int mulsum) {
	mx = max(mx, mulsum);
	// 이 함수의 목표 : 선택한 Group 내에서 최대 수익을 뽑아내기.
	for (int i = 0; i < M; i++) {
		if (check[i]) continue;
        // dq는 항상 선택한값만 존재하므로, i = 0으로.
		if (sum + dq[i] > C) continue;
		check[i] = 1;
		// 하나 채택한 mulsum + 현재 채택한 mulsum
		f(i, sum + dq[i], mulsum + (dq[i] * dq[i]));
		check[i] = 0;
	}
}

void filter() {
	for (int i = 0; i < v.size(); i++) {
		// 두번 비교할 필요가 없을때, j=i+1로.
		for (int j = i+1; j < v.size(); j++) {
			if (g(v[i], v[j])) {
				res = max(res, v[i].mx + v[j].mx);
			}
		}
	}
}

bool g(info& I, info& C) {
	if (I.x != C.x) return true;
	if (I.y < C.y && I.y + M - 1 < C.y) return true;
	if (I.y > C.y && C.y + M - 1 < I.y) return true;
	return false;
}

```

## 22. 04. 24 (일)

 - 1주일간 죽었다 생각하자
