## 알고리즘 - 팰린드롬 수 찾기
 - 앞 뒤의 문자열이 같기 위해서 최소 몇개의 글자가 필요한지 찾는 프로그램으로, DP의 기본적인 문제이다.
 - 완벽히 이해가 되지 않으므로, 그냥 코드를 외우자.
   ```
   int find(char arr[], int n){
       // arr에는 문자가 들어가 있다. ex) "abcde"
       int table[10][10] = {0,};

       for(int gap=1; gap<n; gap++){
           for(int l=0; h=gap; h<n; h++; l++){
                table[l][h] = (arr[l] == arr[h]) ? table[l-1][h-1] : min(table[l-1][h], table[l][h-1]) + 1;  
           }
       }
       return table[0][n-1]; 
   }

## 알고리즘 - LCS(Longest Common Subsequence) 찾기
 - DP의 가장 기본적인 문제로서 부분 집합을 이루는 갯수를 찾는 알고리즘이다.

  ```
  int LCS(char arr[], char brr[], int a, int b){
    if(a == 0 || b == 0){ return 0;}
    else if(arr[a] == brr[b]){ return lcs(arr, brr, a-1, b-1)};
    else{
        return max(lcs(arr, brr, a, b-1), lcs(arr, brr, a-1, b) + 1);
    }  
  }
  ```
 - DP를 확실하게 알지는 못하지만 그래도 알아보는 과정, 문자열에서 같은 요소를 찾을 때 자주 쓰임.