## 알고리즘 - 주사위 윷놀이(2)

 - 처음엔 답 보고 클론 코딩했고 이번엔 혼자 풀어봄. 즈응말 어렵다.

 - 임의의 좌표 배열을 설정하여 warp 시키는 형식으로 풀어봤다.

 - 여기서 주의할 점은 말이 중복되는 경우, 그 게임 자체를 cancel 시켜버리는것.

 - 경로 설정할 때, ***가고 있는 중 경로*** 와 ***끝난 후 가는 경로***가 다르다는 점, 이걸 for문 안에서 설정하는 법이 특이했다.


 CODE

 ```
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int horse[10], maxans = -1;
int check[10] = { 0, };
struct info {
	pair<int, int> str, end;
};
info hor[4];
int answer[4] = { 0, };
void dfs(int depth);
int dice();

int board[9][6] = {
	{0, 2, 4, 6, 8, 10},
{10, 12, 14, 16, 18, 20},
{10, 13, 16, 19, 25, -1},
{20, 22, 24, 25, -1, -1},
{20, 22, 24, 26, 28, 30},
{25, 30, 35, 40, 77, 77},
{30, 28, 27, 26, 25, -1},
{30, 32, 34, 36, 38, 40},
{25, 26, 27, 28, 30, -1}
};

int main() {
	for (int i = 0; i < 10; i++) {
		cin >> horse[i];
	}
	dfs(0);
	cout << maxans << '\n';
	return 0;
}

void dfs(int depth) {
	if (depth == 10) {
		memset(answer, 0, sizeof(answer));
		maxans = max(maxans, dice());
		return;
	}
	for (int i = 0; i < 4; i++) {
		check[depth] = i + 1;
		dfs(depth + 1);
		check[depth] = 0;
	}
}

int dice() {
	for (int i = 0; i < 4; i++) {
		hor[i].str.first = 0;
		hor[i].str.second = 0;
		hor[i].end = hor[i].str;
	}
	int ans = 0;
	for (int i = 0; i < 10; i++) {
		int x = hor[check[i] - 1].str.first;
		int y = hor[check[i] - 1].str.second;
		if (x == 77 && y == 77) continue;

		// 그냥 지나가는 부분인데 이게 시작점이랑 겹치는지 여부는 봐야할듯.
		int nx; int ny;
		bool isfinish = false;

		// 1. 말을 1부터 5까지  한칸 한칸 움직여 보는 과정
		for (int k = 1; k <= horse[i]; k++) {
			// 2. 해당 말의 다음 좌표
			nx = x; ny = y + 1;
			// 다음 좌표가 골인 지점이면 break 시킨다.
			if (board[nx][ny] == 77) {
				hor[check[i] - 1].str.first = 77;
				hor[check[i] - 1].str.second = 77;
				isfinish = true;
				break;
			}
			// 아니라면
			else {
				if (nx == 0 && ny == 5) {
					// 지나가는 도중에 만난다면 이좌표로 가고.
					if (k != horse[i]) {
						x = 1; y = 0;
					}
					else {
						// 종료 지점에 이 좌표라면 여기로 가라.
						x = 2; y = 0;
					}
				}
				else if (nx == 1 && ny == 5) {
					if (k != horse[i]) {
						x = 4; y = 0;
					}
					else {
						x = 3; y = 0;
					}
				}
				else if ((nx == 2 && ny == 4) || (nx == 3 && ny == 3) || (nx == 6 && ny == 4)) {
					// 25일때인데, 이때는 종료 지점이던 아니던 항상 이쪽으로 간다.
					x = 5; y = 0;
				}
				else if (nx == 4 && ny == 5) {
					if (k != horse[i]) {
						x = 7; y = 0;
					}
					else {
						x = 6; y = 0;
					}
				}
				else if (nx == 7 && ny == 5) {
					x = 5; y = 3;
				}
				else {
					x = nx; y = ny;
				}
			}
		}
		// 3. 다 움직이고 난 후 좌표 갱신
		nx = x; ny = y;
		// 4. 말이 골인했다면 다음 말을 이동시킨다.
		if (isfinish) continue;

		// 5. 도착 지점의 (nx, ny)에 다른 말이 있는지 체킹
		bool isavail = true;
		for (int j = 0; j < 4; j++) {
			if (j == check[i] - 1) continue;
			if (hor[j].str.first == nx && hor[j].str.second == ny) {
				isavail = false;
			}
		}

		// 6. 다른 말이 없다면
		if (isavail) {
			// 말의 좌푯값 갱신해준다.
			hor[check[i] - 1].str.first = nx;
			hor[check[i] - 1].str.second = ny;

			hor[check[i] - 1].end = hor[check[i] - 1].str;
			answer[check[i] - 1] += board[nx][ny];
		}
		else {
			// 7. 다른 말이 있다면 그 게임은 무효처리 한다.
			return -1;
		}
	}
	// 8. 답 도출
	for (int i = 0; i < 4; i++) {
		ans += answer[i];
	}

	return ans;
}
```

## 20. 05. 06(수)
 - 혼자 못풀줄 알았는데 그래도 풀 수 있긴 하네 다행.. 시간은 오래 걸렸지만