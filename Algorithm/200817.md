## 알고리즘 - Codeforce Global 10 리뷰

 #### Omkar and Password (A)

```
  상황 : 임의의 배열에서 인접한 두 원소를 빼내고, 그 합을 다시 집어넣는 연산이 있다고 하자.

        단, 인접한 두 원소가 같은 값이면 할 수 없다고 하면 더이상 원소의 길이를 줄일 수 없게 된다.

        Operation을 할 때, 최소로 줄일 수 있는 배열의 길이는?
```
```
  해결 : 초기 상태가 모두 같은 값을 가졌다면 더이상 줄일 수 없음이 확정이다.

        그럼, 연산을 하다가 같은 값이 나오는 경우가 나와 더이상 줄일 수 없는 경우가 있을까?

        답은 No이다. s[j] 상태가 같은 값만 존재하는 경우가 되려면 s[j-1]에서 같은 값이 나오도록 더하도록 강제되어야 한다. 하지만, 다른 경우로 더하면 다른 값이 되므로, 이런 경우는 존재하지 않음.

        그래서 답은 초기 같은 값이 있다면 같은 값의 길이를 출력하고, 아니라면 무조건 1이 된다.
```

  #### Omkar and Infinity Clock (B)

```
  상황 : 임의의 배열에서 최댓값 d를 뽑아낸 후, d - 각 원소 (a[i])를 한 값을 새로운 배열로 하자.

         임의의 배열이 주어지고, 위와 같은 연산의 횟수 k(1<=k<=10^18)이 주어질 때, 연산 후 배열 상태를 출력해라.
```
```
  해결 : 연산 횟수만큼 직접 해 보면 반드시 TLE가 나니까 규칙이 있을 것이라 생각했고, 직접 해보자.

         초기 배열 a와 한번의 연산후 배열 b를 구하고, k가 짝수면 b, 홀수면 a를 출력했다.
        단, k가 10^18이므로 long long을 사용해야 하는 센스
```

  #### Omkar and Waterslide (C)
```
  상황 : 임의의 배열이 주어지고, contiguous segment인 배열들을 1씩 증가할 수 있는 연산이 주어짐.

        이때, 모든 배열이 nondecreasing 상태(오름차순)이 되도록 하려면 연산을 몇번이나 해야할까?
```
```
  해결 : 간단하다. if(a[i] > a[i+1]) ans += a[i]-a[i+1] 끝.
         하지만 매우매우 실수하기 쉬운게 a[i]는 10^9까지이고 i는 200000 까지이다.
         그럼 최악의 경우, 10^9 * 200000 까지 ans가 갈 수 있고, 2*10^14이므로 int의 범위를 넘어설 수 있다. ans를 long long으로 해야 답이 됨을 캐치할 수 있어야 한다.
```

  ![Alt text](./img/img_2008172.png)

![Alt text](./img/img_200817.png)

## 20. 08. 17(월)

 - turn game을 dfs or dp로 나타내는 로직이 굉장히 흥미로웠다.
 - long long 실수 항상 조심하자.
 - 공부하느라 망가진 피부관리 역시도 공부라 생각하고 하자.. T.T 내 자신은 내가 챙겨야..