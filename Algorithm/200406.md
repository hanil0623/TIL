## 알고리즘 - 연구소3 (2)

 1. 교훈 1. N*N의 크기에서 bfs로 바이러스가 퍼질 때, MAX_TIME은 N이 아니고 N*N이다.
    - MAXN의 크기 대충 잡지 마라.. 그냥 습관적으로 제일 큰 값 잡는게 안전할듯. 객기 ㄴ

 2. 교훈 2. dfs → bfs 로 진행하므로 반례를 알아서 생각해야 하는게
    - 진행할 수 없음(-1) + 진행 가능함(res) 가 있을 때, res를 출력할 수 있는가?
    - 이건 진행할 수 없는 경우의 수를 임의로 크게 키워서, min에 안걸리게 하면 된다.
    - 진행할 수 없는 경우를 9999로 하면, 진행 가능한 time은 MAX 2500이므로, 우선순위가
    - 진행할 수 없는 경우가 된다. 하지만, 진행 할 수 있다면 값은 2500 밑으로 내려가 갱신되므로 다음 case에 진행할 수 없는 경우인 9999가 오더라도 갱신되지 않는다.

 3. 교훈 3. 각 노드의 상태를 모두 나열한 후, for문 돌려 이런 경우는? 이런 경우는? 생각하는 태도를 계속 유지하기
    - 문제에서 [활성 상태의 Virus] + [비활성 상태의 Virus] 일 때 구체적으로 time이 증가 하는지 아닌지 명시를 하지 않아 헷갈렸다. 이럴땐 ***문제에 명시된 표현인 (활성 상태의 바이러스가 복제할 때 time이 증가)*** 라고 하였으므로 이 외의 경우는 time을 증가시키지 않는다. 단, 활성 상태가 된다고 하였으므로 check = 1, q.push는 해 줬다.

 4. bfs + 특정 state의 node 개수를 세는 행위가 나왔다면
    - bfs 돌때마다 맵 전체를 도는 방식 말고 input 받을 때 부터 목표 state 값을 체킹해 두고, bfs 돌면서 지워나가는 방식을 사용할 줄 알면 좀 더 쉬울 것이다.


## 알고리즘 - 아기 상어(2)

 1. 교훈 1. 먹는 물고기의 우선순위가 있다. 이걸 pq와 q로 표현했다.
    pq는 오로지 한번의 bfs 이후 먹을 수 있는 물고기의 목록만 넣도록 했다.
    단, 여기서 우선순위를 제대로 작성하지 못해 시간이 좀 더 걸림.
    우선순위는 (거리, x, y)의 순서였다. 문제 제대로 읽자..

 2. 목표 대상까지 움직이는 행위 → 먹고 size 불리는 행위 + status 관리의 연속이였다.
    큐로 한번에 표현하려고 하다가 시간끌었다.
    유연하게 사용할 수 있음을 잊지말자.


## 알고리즘 - 갑자기 생각난 구조체 sorting법 + 잡기술
    1. 자주 나오니까 외우자!!
    ```
    struct compare{
        bool operator()(vector<string> &I, vector<string> & C){
            if(I[0] != C[0])
                return I < C;
            return I[0].compare(C[0]) < 0; // 같을때 어케하는지
        }
    }
    ```
    2. String to int!
     - int a = atoi(string.c_str());
    3. int to String!
     - String a = to_string(a);

## 알고리즘 - 탈출(2)

  1. 교훈 1. 일단 이 문제는 한 공간 안에 두개의 Object가 각기 bfs를 하고 있다.
    단, Object 간의 위계관계가 있어 생각해야 할 것은
    Obj_1과 Obj_2가 한 공간에 만났을 때 어떻게 처리하는가? 이다.
    위계관계가 있으니 상태변수를 나타내는 check[x][y][state]를 두어 처리하는 기법! nice

  2. 이미 Obj_1에 휩쓸렸다고 하더라도 예외조건을 두어 처리하는 방식이 새로웠다.
  ```
  // 물에 휩싸였지만 고슴도치의 다음 장소가 굴이라면?
  // 아니면 정상적으로 다음 장소가 굴이라면?
  if (check[hx][hy][0] && map[nx][ny] == 'D' || map[nx][ny] == 'D') {
	    isfinal = true; ans = hdist + 1;
		break;
  }    
  ```

  3. depth 별 bfs를 다시금 연습할 수 있는 nice한 기회!
  ```
  while(depth--){
      int qsize = q.size();
      while(qsize--){
          for(i<4){
              nx ny 두어 진행
          }
      }
  } 
  ```

## 20. 04. 06(월)
 - 풀었던거 또 푸는데 참 도움이 많이 된다. 생각하는 방법도 바뀌고 좋은 것 같다.
 - 단, 하루 2문제씩 푸는걸 습관화 하자.
 - 아침운동 꼭 해보자.
