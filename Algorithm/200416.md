## 알고리즘 - 열쇠
  
  1. 일반적인 시작점(0,0)이 아닌 점에서 특이했다.
    = 즉, ***시작점 조차도 처리해야 할 Object가 여러개인 사실***을 간과.

  2. 처리해야 할 Object가 여러개였다. (문, 열쇠, 문서, 길, 벽)

  3. 한 번의 bfs로 열쇠를 얻고, 종료 조건을 처리하기 까다로웠다.
   = 한 번의 ***bfs는 (들어올 수 있는 시작점 모두에서 진행을 기준)***
   = 한 번의 instruction bfs를 어떤 단위로 설정할까? 에 대한 생각이 까다로웠음.

   = 한번의 bfs 당 열쇠를 얻을 수 있다면 계속 진행(진행할때마다 문을 열 수 있으니까)
    + 각 ***문의 상태를 set<pair<int, int>>로 관리***해줬으며, 문을 열 때마다 set.erase(element) 관리.

  4. 각 열쇠의 상태를 대문자라면 -'A'를 하여 keyset 배열로 관리 !

  5. 한 번의 bfs로 처리할 수 있던데 어떻게 했을까? 좋은 코드 보며 시간절약 해보자.


## 20. 04. 16(목)
 - 골드 1 문제를 내 코드로 직접 풀어낼 수 있어서 기뻤던 날~ 시간절약 + 복습은 필수
 - 그와 동시에 많은 문제 무조건 풀어봐야한다. 300문제 정도는 풀어봐야 익숙해질듯.



