## 알고리즘 - 트럭(Python, 시뮬레이션)

 1. Flow Control 문제는 flow가 적용되는 공간, 시간 개념이 주어진다.
  - 이때 보통 큐가 사용되는데 큐는 삽입, 삭제가 빈번히 이뤄지므로 반드시 **고정 인덱스값을 사용해야 할 때, 큐가 빈 경우는 없는지 확인** 후 사용하는 습관 들일것

 2. 특정 공간(다리)에 insert 하기 전, 반드시 **공간에 popping 작업 후 짜는 습관**
  - 주차장에 차가 나가야 다른 차가 들어올 수 있다.

 3. time check 할 때 보통 while문의 마지막에 time++ 하니까 정확한 시뮬을 위해선
  - while True
  - 0초일 때 시뮬레이션
  - time++ (0 ~ 1초 증가)
  - 종료 조건 체킹
  - 위 순서대로 반드시 format을 갖춰 코딩하는 습관 기르자.


## 알고리즘 - 해시 공부

 1. 해시란 **n개의 정보를 지닌 객체를 정수 하나로 표현가능한 기법이다.**

 2. Modular 연산값은 주로 10^9+7, 2^55-1 자주 사용한다.

 3. S1,S2,S3...Sn의 해시값 h[i] : 1 ~ i까지 prefix 문자열의 해시값이다.

  - h[i] = (h[i-1]*26 + Si-'a') % D (Modular)

 4. 위 값을 전처리(O(n))으로 구해놓은 다음,

  - [ h[i] - h[j-1] * 26^(i-j+1) = j부터 i까지 부분 문자열의 해시값이다.]

  - 이때, 26의 n제곱값을 미리 배열에 가지고 있는 것이 좋다.(p[i] = p[i-1]*26)

 5. 구간 성분(BOJ)

  - ex) drdesde와 edsrdde가 해시값이 같음을 어떻게 알 수 있을까?

  - 문자열 : n차원 벡터에 각 값들은 26 이하의 값들로 구성되어 있다고 볼 수 있다.

  - 구간성분 : 26차원 벡터에 각 값들은 1500 이하로 구성했다고 볼 수 있다.

  - aa[i] = aa[i-1]*1501^(a[i]-'a')로 표현 가능.

  - aa[i] - aa[j] = 문자열 j+1부터 i까지 구간성분의 정보를 나타낸다.

  - 즉, 어떤 구간 k에서 (anum, bnum, cnum, ... znum) 값이 같다면 동일하다 말할 수 있다.

  - pseudo code

  ```
  for(i=k; i<=n; i++){
      // 구간성분 k에 따라 각 구간의 정보가 모두 s에 들어간다.
      s.insert(h[i] - h[i-k]);
  }
  for(i=k; i<=m; i++){
      if(s.find(T[i] - T[i-k]) != s.end()){
          // 정답 처리.
      }
  }
  ```

## 20. 06. 30(화)

 - 뭐든 더 열심히 하자. 나태해 지면 안된다~~ 무엇이던 더 배우려고 하고

