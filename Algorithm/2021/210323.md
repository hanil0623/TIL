## 알고리즘 - 미친 아두이노(vector ver)

 - 벡터로 할 때 중요한점.

```
 for(moving){
     // 밑에 arduino에서 받은 신호를 알아먹을 수 있게끔.
     if(!isok) break;

     for(arduino){
         // 이곳에서 isok = false가 나와 게임이 종료가 되어야 하는 경우,
         // 이 isok 신호를 반드시 위에서도 알 수 있게 코드를 짜야 한다.    
     }
 }
```

 - 중복 체킹은 check++로 한다.

 - 벡터로 할 경우, 죽은 애들은 continue 처리 해준다.

 - 처음 아두이노를 이동시키는 순간 map[arx][ary] = '.' 해주고

 - 중복처리 후 아두이노가 하나만 있는게 확정되는 순간 map[arx][ary] = 'R' 해준다.

## 알고리즘 - 프로세서 연결하기

 1. **최대로 많이 설치했을 때 선택할 수 있는 최소길이를 구해야 하는 특이조건**

  - f의 인자로 설치개수도 넣어야 한다.

  - f(인덱스, depth, 설치개수, 길이)

```
	if (d >= v.size()) {
		// 최대로 많이 설치했을 때 선택하는 최소 길이.
		if (ins > ans2) {
			ans2 = ins;
			ans = lan;
		}
		// 설치 개수가 같은 경우에는?
		else if (ins == ans2) {
			// 그렇네. 설치 개수가 같은 경우에 최소 길잇값 갱신해줘야지.
			ans2 = ins;
			ans = min(ans, lan);
		}
		return;
	}
```

 2. 선을 긋는 과정에서 임시벡터를 하나 만들어 좌표 저장하고 긋고 지우면 편하다.

  - vector<pair<int, int>> tmp;

 3. 이렇게 프로세서가 연결되어 있는 경우엔 가지치기를 할 필요가 없다는 사실을 분명히 활용해야 TLE가 나지 않는다.

 ```
 if (i == 0 || j == 0 || i == n - 1 || j == n - 1) continue;
 v.push_back({i, j});

 이렇게 하면 기존 바운더리에 존재하는 코어는 빼고 계산하게 된다. depth가 적어지겠지. 시간 줄이는데 매우 중요함.
```

## 21. 03. 23(화)

 - 계속 달린다. 오우 좋은 교훈 얻었다