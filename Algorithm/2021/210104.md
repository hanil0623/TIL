## 알고리즘 - 트리의 부분집합, Barn Painting Code 비교 (dp_tree)

```
트리의 부분집합

dp[v][0] = Σ max(dp[u][0], dp[u][1])
dp[v][1] = Σ dp[u][0]

void f(int v, int p) {
	int s1 = 0, s2 = 0;
	for (auto x : u[v]) {
		if (x == p) continue;
		f(x, v);
		s1 += max(dp[x][0], dp[x][1]);
		s2 += dp[x][0];
	}
	dp[v][0] = s1;
	dp[v][1] = s2 + w[v];
}

```

```
Barn Painting

dp[v][0] = π (dp[u][1] + dp[u][2]) = dp2[v][0]
dp[v][1] = π (dp[u][2] + dp[u][3]) = dp2[v][1]
dp[v][2] = π (dp[u][0] + dp[u][1]) = dp2[v][2]

실제 계산할때 더하기 부분을 dp2로 먼저 계산 후, 파이를 계산해준다.

void f(int v, int p) {
	if (c[v]) dp1[v][c[v]] = 1;
	else dp1[v][1] = dp1[v][2] = dp1[v][3] = 1;
	for (auto x : u[v]) {
		if (x == p) continue;
		f(x, v);
		// 곱셈은 여기서 한다
		for (int k = 1; k <= 3; k++)
			dp1[v][k] = dp1[v][k] * dp2[x][k] % D;
	}
	// dp2[parent][0] = dp1[child][1] + dp1[child][2] 으로 계산하는 테크닉
	dp2[v][1] = (dp1[v][2] + dp1[v][3]) % D;
	dp2[v][2] = (dp1[v][1] + dp1[v][3]) % D;
	dp2[v][3] = (dp1[v][2] + dp1[v][1]) % D;
}

```

## 21. 01. 04 (월)

 - Remind
