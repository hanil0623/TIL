## 알고리즘 - 주난의 난(bfs, dfs)

 - Time 당 1로 둘러쌓인 부분까지 bfs, dfs를 움직임을 제어할 수 있는지가 포인트

 ![Alt text](./img/img_210228.jpg)

 1. dfs로 풀기

```
void dfs(int x, int y){
    if(check[x][y]) return;
    check[x][y] = 1;

    for(4방향){
        nx, ny 선언;
        if(범위 초과) continue;
        if(map[nx][ny] == '0') dfs(nx, ny);
        else if(map[nx][ny] == '1'){
            // 1이면 갔다고 표시하고 map을 0으로 바꿔줬던게 핵심
            check[nx][ny] = 1;
            map[nx][ny] = '0';
        }
        else if(map[nx][ny] == '#'){
            isok = true;
            break;
        }
    }
}

while(!isok){
    ans++;
    // 이러면 매 순간 map을 뚫고 원점부터 새로 나아가야 해서 좀 느림
    memset(check);
    dfs(sx, sy);
}
```

 2. bfs로 풀기

```
  queue<pair<int, int>> q, nq;
  void bfs(int x, int y){
      q.push({x, y});
      check[x][y] = 1;
      while(1){
        Time++;
        while(!q.empty()){
            if(x == ex && y == ey) return Time;
            if(범위 체킹) continue;
            if(map[nx][ny] == '0') q.push({nx, ny});
            else nq.push({nx, ny});
            check[nx][ny] = 1;
        }
        // 이후 q는 empty일테고 nq는 있을테니까 nq를 q로 모두 옮김.
        q = nq;
      }
  }
```

## 21. 02. 28(일)

 - dp는 항상 중요하다

 
