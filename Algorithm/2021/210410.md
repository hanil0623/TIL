## 알고리즘 - 야구

 1. 9! 정의하는데 첫 타수의 순번이 fix 된 경우 어떻게 할 것인가?

```
check[0] = 4;
f(1, cnt);

void f(int d, int c){
    if(c == 4) c++;
    if(d >= 9){
        // 시뮬 로직
    }
    for(int i=0; i<9; i++){
        if(check[i]) continue;
        check[i] = c;
        // c++을 해버리면 오류남 조심.
        f(d+1, c+1);
        check[i] = 0;
    }
}
```

2. 순서가 정해진 check 배열을 새로 sort 하기.

```
    // 순번, 인덱스꼴 정의
    vector<pair<int, int>> ord;
	for (int i = 0; i < 9; i++) {
		ord.push_back({ check[i], i });
	}
    sort(ord.begin(), ord.end());
```

3. 도루 시뮬레이션 하기

```
	ru[0] = 1; // 타자가 하나 생김
    // x = 1루타 2루타 3루타
	for (int g = 0; g < x; g++) {
        // 역순으로 한칸씩 밈
		for (int k = 3; k >= 0; k--) {
			ru[k + 1] = ru[k];
		}
        // 타수 이동
		ru[0] = 0;
        // 만루하면 초기화 후 점수
		if (ru[4]) {
			ans++; ru[4] = 0;
		}
	}
```

4. Fail **홈런칠 때 루를 초기화 해야 하지 않았음**

5. Fail **3 out 시 루를 초기화 하지 않았음**

6. **3 out 시 다음 타자의 인덱스를 제대로 설정하지 못함**

```
if(out == 3){
    // ru 초기화

    // 이렇게 하면 오답임. (next+j)%9로 인덱스가 계속 가니까 만약, next = 7이고 j = 7인 상태에서 3 아웃이 났다면, 다음 next는 6이 나와야 정상이다. 하지만 j+1을 해버리면 8이 나오니까 오답임.
    next = j+1;

    next = (next+j+1)%9로 해야 정상 작동함.
}
```

7. 타자가 돌다가 아웃당할 경우, 다음 타자를 어떻게 나타낼까?

// next 변수를 활용해서 아웃 당했을 때 이전 값을 기억시키면 손쉽게 가능하다.
- int x = p[i][ord[(next+j)%9].second];

## 알고리즘 - 톱니바퀴

 1. 연쇄작용 일어나는 톱니바퀴가 움직일 수 있는지 없는지 먼저 판단한 후에 방향값을 기억하고 있다가 나중에 한번에 움직인다는 사실을 캐치할 수 있는가?

  - 그래서 먼저 bfs를 돌려보고 정함.

  - check (bfs 중복 체킹), visit(각 톱니바퀴의 pinset 체킹), sig(움직여야 할 방향 체킹)

 2. pinset이 양방향으로 움직이는데 롤링 인덱싱을 잘 할 수 있는가?

  - pin = ((pin + direction) + 8) % 8;


## 21. 04. 10(토)

 - 역시 다시 풀어봐야 확실한 내 것이 됨. 디테일한 부분에서 안풀어보면 실수하는게 시뮬임 풀고 또 풀자.

 - 6000B -> 3000B -> 1500B 까지 줄일 수 있는 실력이 올라옴에 감사