## 알고리즘 - 동전 시리즈 비교

 - 동전 0 : n개 종류의 동전으로 k원을 만드는데 **최소 동전의 개수**를 묻는 문제인 경우이다. "최소" + "개수" == 그리디적으로 쉽게 생각하여 액수가 큰 금액부터 나눠가면 된다.

 - 동전 1 : n개 종류의 동전으로 k원을 만드는 **경우의 수**를 구하는 것이다. ex) 20원을 만드는데 10원짜리 동전이 있다면, dp[20] += dp[10]과 같다. 어차피 10원을 만드는 경우의 수에서 10원을 더하면 되므로, 경우의 수 자체는 그냥 10원의 경우의 수를 끌어오면 된다.

  > 이 경우는 무게별로 역순을 취할 수 있다.

 - 동전 2 : 역시 최소 동전의 개수를 구하는데 음.. 솔직히 차이점은 모르겠네.

```
	for (int i = 1; i <= k; i++) {
		for (int j = 1; j <= n; j++) {
			if (i - a[j] >= 0) {
                // 이전 동전에서 하나를 추가하는 수와 기존의 수를 min으로 비교하는 작업정도는 알아두자.
				dp[i] = min(dp[i - a[j]]+1, dp[i]);
			}
			else continue;
		}
	}
```

 - 동전 바꿔주기

  - 요건 각 동전의 개수가 존재함. 풀이 역시 2차원과 1차원 두개가 존재한다.

 - 1차원 사용할 경우, 각 동전을 한번씩만 사용해야 하므로 무게를 역순으로 돌려준다.

```
	// 2차원 dp[i][j] : i 무게를 1 ~ j까지 인덱스 사용할 때 경우의 수
	sort(p+1, p+k+1);
	dp[0][0] = 1;
	for (int i = 1; i <= k; i++) {
        // 동전의 개수를 고정시키고 무게를 젤 먼저 돌리는구나.
		for (int j = 0; j <= p[i].second; j++) {
			for (int g = 0; g <= t; g++) {
				if (g - p[i].first * j >= 0) {
					dp[g][i] += dp[g - p[i].first * j][i - 1];
				}
			}
		}
	}
	cout << dp[t][k];

    // 1차원 dp[i] : i 원을 나눠줄때 경우의 수
	dp2[0] = 1;
	for (int i = 1; i <= k; i++) {
        // 무게를 역순으로 돌려준다.
		for (int j = t; j >= p[i].first; j--) {
			for (int g = 1; g <= p[i].second; g++) {
                // 넘는 경우, continue가 아니라 break를 해주는 깔끔함.
				if (j - g * p[i].first < 0) break;
				dp2[j] += dp2[j - p[i].first * g];
			}
		}
	}
	cout << dp2[t];
```

## 21. 03. 20(토)

 - 아이고 할게 많다.