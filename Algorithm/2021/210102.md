## 알고리즘 - 잡다 문제 모음

- 1. 5 10 7 3 8 의 숫자 중 큰 숫자 순으로 순회하고 값을 바꿔주는 행위는 "우선순위 큐"를 사용하면 쉽게 할 수 있다. 즉, 숫자 덩어리에서 큰 값 짚어서 Action을 하는 행위를 하려면 우선순위 큐를 사용하자.

- 2. aaaaabbbbc 일때, 글자를 n개까지 임의 삭제하여 얻을 수 있는 C = Max A - min B의 최솟값을 구하기

    + 임의 삭제가 가능함
    + 수식의 최솟값 구하기

    ```
    이분 탐색을 활용해 보자.

    C의 범위는 최소 0 ~ len-1 까지이고 예시로 적어보는 습관이 중요하다.

    C가 4일땐 0개 삭제

    C가 3일땐 1개 삭제

    C가 2일땐 3개 삭제

    C가 1일땐 5개 삭제

    C가 감소할수록 삭제 수는 증가한다.
    ```

- 임의의 C를 설정 후 값이 n보다 작다면 답 리스트에 추가할 수 있다.

```
- x = C이고 C를 하기 위해 필요한 삭제 수를 리턴하는 함수
int myf(int x, int mn) {
	int res = 0;
	for (int i = 0; i < 26; i++) {
        // ex) aaaaabbbbc에서 각 알파벳을 돌며
        // C가 1이 되기 위해선 a.len - mn 개를 빼야하고
        // b에서는 b.len - mn개를 빼야 한다.
        // mn + x = a,b의 최대개수이며, 이는 alpha[i]를 넘어설 수 없다.
        // max값으로 0과 비교하는 테크닉이 엄청 nice 함
		res += max(0, alpha[i] - (mn + x));
	}
	return res;
}
```

3. Graph에서 시작점 -> 중간점 -> 끝점을 거쳐 가는 경로의 수 구하기.

- DFS로 풀면 당연히 O(2^n)이므로 TLE가 난다.

- 이런 문제 조차도 DP로 풀어야한다는 점..

## 21. 01. 02 (토)

- DP, Greedy, AD-hoc, Implementation 매우 약하고 문제를 보는 능력도 약함.
