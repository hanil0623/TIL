## 알고리즘 - 전구를 켜라(다익스트라)

 - 격자를 회전시키는 행위를 cost = 1로 보면 다익스트라로 쓸 수 있다.

 - 이 문제의 포인트는 격자점 기준과 map 기준점 두개를 동시에 활용하며 다익스트라를 적용시킬 수 있냐는 것이다.

 - 특히, 8방향이 아닌 4방향 만으로 싱크를 맞추는 기법 매우매우 중요하다.


```
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
int n, m;
int map[505][505];
int dist[505][505];
int dx[4] = { 1, -1, -1, 1 };
int dy[4] = { 1, 1, -1, -1 };

// next 좌표가 ↗면 map은 현재 좌표에서 ↑ 방향이고
// ↖면 map도 ↖ 이고, ↙면 ←이고 ↘면 그대로이다.
int bx[4] = { 0, -1, -1, 0 };
int by[4] = { 0, 0, -1, -1 };

priority_queue<pair<int, pair<int, int>>> pq;
int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	cin >> n >> m;
	fill(&dist[0][0], &dist[504][505], 1e9);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			char p; cin >> p;
			if (p == '\\') map[i][j] = 1;
			else map[i][j] = 2;
		}
	}
	
	dist[0][0] = 0;
	pq.push({ 0, {0,0} });
	
	while (!pq.empty()) {
		int cost = -pq.top().first;
		int x = pq.top().second.first;
		int y = pq.top().second.second;
		pq.pop();
		
        // <= 기호 사용하면 안됨. (저격 데이터 방지)
		if (dist[x][y] < cost) continue;

		for (int i = 0; i < 4; i++) {
            // nx, ny : 격자점 기준의 next 좌표
			int nx = x + dx[i];
			int ny = y + dy[i];

            // nx, ny에 맞물리는 map 좌표
			int ax = x + bx[i];
			int ay = y + by[i];

            // nx는 격자점이므로 n, m까지 허용
			if (nx < 0 || nx > n || ny < 0 || ny > m) continue;
            // ax, ay는 map 기준이므로 n-1, m-1 까지 허용
			if (ax < 0 || ax >= n || ay < 0 || ay >= m) continue;

            // 현재 격자점에서 방향이 ↘, ↖이고 해당하는 맵이 ＼ 라면 그대로 감
			if (i % 2 == 0 && map[ax][ay] == 1) {
				if (dist[nx][ny] > dist[x][y]) {
					dist[nx][ny] = dist[x][y];
					pq.push({ -dist[nx][ny], {nx, ny} });
				}
			}
            // ↗, ↙이고 맵이 / 라면 그대로 감
			else if (i % 2 == 1 && map[ax][ay] == 2) {
				if (dist[nx][ny] > dist[x][y]) {
					dist[nx][ny] = dist[x][y];
					pq.push({ -dist[nx][ny], {nx, ny} });
				}
			}
            // 아니라면 cost+1 더해준다.
			else {
				if (dist[nx][ny] > dist[x][y] + 1) {
					dist[nx][ny] = dist[x][y] + 1;
					pq.push({ -dist[nx][ny], {nx, ny} });
				}
			}
		}
	}
	if (dist[n][m] == 1e9) cout << "NO SOLUTION";
	else cout << dist[n][m];
	return 0;
}
```

## 알고리즘 - 3인 통화(다익스트라)

 - P1.  **세 점을 지나치는 경로** 라는 특성을 이용해 **다익스트라 3번**을 돌려놓을 수 있는가?

 - P2. 세 점끼리 다이렉트로 만나는 경우, 한 점을 거쳐 만나는 경우만 있음을 구별할 수 있는가?

```
    // ans1은 다이렉트로 만나는 경우
	int ans1 = dist1[s2] + dist2[s3] + dist3[s1];
	int ans2 = 1e9;
	int spot = 0;
    
    // 한 점을 거쳐 만나는 경우는 모든 노드를 순회하며 최솟값과 그때의 node를 찾는다.
	for (int i = 1; i <= n; i++) {
		if (ans2 > dist1[i] + dist2[i] + dist3[i]) {
			ans2 = dist1[i] + dist2[i] + dist3[i];
			spot = i;
		}
	}
	ans = min(ans1, ans2);
```

 - P3. dijkstra tracking을 할 수 있는가?

 > tracking dp와 dijkstra의 tracking은 차이가 있다.

 - dijkstra는 모든 노드를 순회할 필요가 없으므로 while로 풀 수 있다.

 - 끝 점부터 반대로 순회함을 잊지말자.

```
void track(int s, int e){
    int x = e;
    
    // x는 계속 변하는 지점이고 s는 시작점임.
    while(x != s){
        for(int i=0; i<v[x].size(); i++){
            int next = v[x][i].first;
            int cost = v[x][i].second;
            
            // dist[x] + cost == dist[next]가 아니다. 역순이므로 조건 주의
            if(dist[next] + cost == dist[x]){
                b.push_back({x, next}); // 역순회 경로 주입
                x = next; // 순회 경로를 바꿔줌.
                break; // 갱신했으면 break 필수로 해야 함.
            }
        }
    }
}
```

## 21. 02. 15(월)

 - 리조트, 동전 바꿔주기, 평범한 배낭, 라그랑주의 네 제곱 정리, 동전 시리즈 dp 묶어서 새로 개념 재정립 ㄱ

