## 알고리즘 - 안정적인 문자열(Greedy)

 > :star:**괄호를 반대로 바꿀 수 있는 연산**:star:이 있다고 할 때, 주어진 괄호의 쌍이 맞게 하는 최소 연산 횟수를 구하여라.

 - 스택이 비었는데 오른괄호가 온다면 해당 괄호를 왼괄호로 바꾸고 스택에 넣는다.

 - 그렇지 않다면 오른괄호가 나올때마다 스택을 pop한다.

 - 이렇게 한바퀴 돌면 최종적으로 스택에 남은 사이즈는 **괄호의 쌍이 맞지 않은 괄호만** 남게 된다.

 - 이들 사이즈 / 2 만큼 연산을 해주면 괄호의 짝이 맞게 된다.

## 알고리즘 - 카드 놓기 (dfs)

 > 카드에 정수가 적혀있고 이를 K개 뽑을 때 카드에 적힌 숫자를 이어붙인 수들의 경우의 수를 구하여라.

 1. ex) "21", "1", "3" = 2113으로 만들 수 있는가?

```
 # 카드에 적히는 수 자리를 보고 인자로 값만 넣어 관리하는 방법이 시간 절약은 가능.

 1. 카드가 최대 2자리 까지 오는 경우엔 이렇게 간단하게 관리할 수 있다.

  int next_num = 10*num(param);
  if(card[i] > 9) next_num *= 10;
  f(depth+1, next_num+card[i]);

 2. 카드에 올 수 있는 범위가 매우 큰 경우, to_string 해 버리면 쉽게 해당 숫자의 자리를 알 수 있다.

  이후 벡터에 모든 수를 한자리씩 끊어 넣어둔 다음, 다시 일일이 합쳐버리면 깔끔하게 구할 수 있다.
```

## 알고리즘 - 카드 문자열 (Greedy)

 - 같은 카드 문제인줄 알고 풀었다가 메모리 초과남. 아마 시간초과도 날듯

 - n이 1000이라 최대 2^n의 경우일 수 있으므로..

```
 if(덱이 비었다면) 문자를 넣는다.

 else if(덱의 front 문자와 비교하려는 문자가 같거나 사전상 앞선다면) dq.push_front()

 else 아니라면 dq.push_back()
```

 - O(n) 만에 해결 가능함. 같은 문제같은데 다른 풀이가 요구되는 아주 신박한 문제들.

## 알고리즘 - 도서관 (Greedy)

 > 한 번에 처리할 수 있는 책이 최대 M권이고 시작점은 0일때, 최소의 걸음으로 모든 책을 정리할 값은?

 1. 거리 순으로 정렬 후, 가장 거리가 먼 곳부터 차례로 M개씩 정리할 수 있는 생각을 할 수 있는가?

 2. 마지막은 돌아올 필요가 없으니까, 먼저 계산 후 값을 뺄 수 있는가?

```
 for(int i=0; i<plus_list_size(); i+=M){
     // plus엔 거리가 가장 먼 곳부터 내림차순 정렬 되어 있다.
     result += 2*(plus_list[i]);
 }
 for(int i=0; i<minus_list_size(); i+= M){
     // minus엔 마찬가지
     result += 2*(minus_list[i]);
 }
 이렇게 하면 마지막도 정리하고 돌아오는 거리까지 합쳐진 경우므로
 plus와 minus 중 거리가 먼 값을 한번 빼주면 답이다.
```

## 21. 03. 06 (토)

 - 그리디 유형 자주 풀어봐야함

 - 프렌즈 사천성 // 틱택토 괜찮은 문제

 