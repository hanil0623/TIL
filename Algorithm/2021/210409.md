## 알고리즘 - 나무 재테크

 1. sort는 I < C 가 오름차순 정렬임.

 2. TLE의 이유는 일단 time이 1000이고 **죽은 나무를 소팅하는 과정이 overhead가 심함**

  - 좌표 별로 임의의 벡터를 만들어 매순간 살아있는 나무만 남긴다면, 소팅 시간이 줄어 시간 안에 통과 가능하다.

  - 구현을 하면서도 항상 **object가 소멸**할 때, 살아있는 Obj만 남길지 아닐지 판단해 보는 버릇 가지자.

## 21. 04. 09(금)

 1. 만약 게임을 하다가 마우스 interrupt가 들어오는 상황일때 Thread가 없다면. 프로세스는 block 상태로 가서 이전 화면을 저장했다가 마우스가 다 움직였을 때 ready 상태가 되어 자기 차례로 프로세서 할당되길 기다렸다가 할당받을 때 화면에 띄워주게 된다. 그땐 마우스로 움직이는 화면이 보여지질 않는다.

 2. Context-switching이 왜 Overhead가 클까? 일단 CS는 현재 run하고 있는 프로세스가 가진 자원을 반납하는 과정에서 현재 상태를 disk에 저장하고, 다음 할당받을 프로세스의 자원을 들고와야 하는 과정이 생긴다. 여기에서 큰 부하가 걸림.

 