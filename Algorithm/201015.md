## 알고리즘 - 차량 정비소(4)

 1. **시간 순서대로 들어오는 고객의 시간값을 캐치하여 [접수 대기 큐]에 넣는 과정**

```
for(T = 0; ; T++){
    // 큐에는 대기 손님의 번호만 넣는다. 이때, j는 반드시 1부터.
    // c[i] = {1, 2, 5, 7 ...}와 같이 고객의 도착 시간표를 배열로 넣고,
    // c배열 전용 인덱스 값을 순회하며 조건에 만족할때마다 더해간다.
    ★ while(j <= k && c[j] == T) q1.push(j++); ★

    // 위 과정을 완료하면 현재 시간에 도착한 고객들의 넘버만 모인다는 사실.
    { ... }
}
```

2. 고객 기준으로 접수, 정비 번호값 관리하는 자료구조를 따로 만들어 관리하는 방법

```
- 접수대 : pair<고객 번호, 들어온 시간> aa[MAX];
- 정비대 : pair<고객 번호, 들어온 시간> bb[MAX];
- 접수 대기 큐 : queue<고객 번호> q1;
- 정비 대기 큐 : queue<고객 번호> q2;
- 고객 관리 배열 : pair<접수대 번호, 정비대 번호> cc[p_MAX];
- TimeTable : 고객의 접수대 도착 시각을 모아놓은 배열

A. 1번과 같이 먼저 timetable, tidx를 순회하며 시간 T에 도착한 고객의 번호만 q1에 넣어둔다.

B. 접수대에 사람 있으면 다 빼어서 정비 대기 큐에 넣어둔다.

C. 접수대가 비었고 접수 대기큐에 사람이 있다면 접수대를 채워준다.

D. 정비대 사람 있으면 다 빼고, 고객 관리 배열을 업데이트 해준다.

E. 정비대 비었고 정비 대기큐에 사람 있으면 정비대 채워준다.

중간중간 고객 관리 배열에 접수, 정비번호 채워주고 구현.
```

## 알고리즘 - 새로운 게임 2(4)

 - 40분컷 정말 운좋다.

 - 그마나 이슈인건 삭제할때, v.erase(v.begin() + z); z--;는 위험함.
 - 저렇게 삭제해야 하는 경우는 1 2 3 4 5에서 중간값 하나만 삭제하는 경우에 유용함.

 - 이 문제같은 경우 위에 것들 모두 삭제되야 하는 무결성이 보장이 되니까 삭제해야 하는 삭제 카운트를 잡고 while(ecnt--) v.erase(v.begin()+IDX)로 고정 위치를 계속 삭제하는 방식을 사용하니 쉽게 됬다.

 - 시뮬 할때 중요한게 무결성이다. 어떤 Action을 함에 있어 이 행동만 해도 됨이 보장되는가? 를 항상 생각하며 코딩해야 빠르고 쉽게 풀 수 있다.

 - 그리고, 문제를 읽으며 항상 내가 이해한 내용이 예제에 그대로 적용되었는지 확인해라. 만약 설계가 쉽게 되지 않는다면 그냥 다른문제 먼저 풀어라. 다 보는것도 전략이다.
 
## 20. 10. 15(목)

 - 이번주만 버티자 다음주 부턴 개발개발에 집중할 수 있다.!!! 이번주만 제에바아알

