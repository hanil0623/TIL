## 알고리즘 - 돌 게임 4 (dp + game)

 - 게임 이론에서 가장 중요한 것은 **:star:dp를 선공이 이길 수 있는지 없는지 정의하는 것:star:**이다.

 - 보통 dp는 어떤 state 가지고 놀며, 점화식을 쓴다. 이때 이전 state와 현재 state의 관계를 선공, 후공으로 나눈다.

 ```
  dp[i] = 돌이 i개 있을 때, 최적의 게임으로 진행할 시 내가 이길 수 있는가?

  선공의 입장에선 돌을 1, 3, 4개 짚을 수 있다. 즉, dp[i]는 dp[i-1], dp[i-3], dp[i-4]의 상태로 갈 수 있다는 얘기이다.

  이때, dp[i]는 선공(상근)의 입장이며, 점화식의 비교 대상이 되는 dp[i-1], dp[i-3], dp[i-4]는 후공(창영)의 입장이 된다.
```

 - dp[0] = 1, dp[1] = 0 임은 알 수 있다. 상근의 차례에서 돌이 하나도 없단 얘기는 창영이가 남은 돌을 모두 가지고 가서 게임에서 졌다는 의미니까 상근이 이겼다는 의미이다.

 - 이 정보를 활용하여 bottom-up을 한다.

 - 그래서 선공이 1,3,4개의 돌 중 하나를 짚고 다음 턴(후공)이 될 때, 후공의 상태 중 하나라도 0(후공이 이길 수 없는 상태)가 되는게 있다면 최적의 게임을 하므로, 선공의 값은 1이 된다. 코드로 보면

```
 for(int i=1; i<=n; i++){
     if(i>=1 && dp[i-1] == 0) dp[i] = 1;
     if(i>=3 && dp[i-3] == 0) dp[i] = 1;
     if(i>=4 && dp[i-4] == 0) dp[i] = 1;
 }

 if(dp[n]) "상근 win"
 else "창영 win"
```

## 20. 08. 22 (토)

 - 이렇게 코드가 간단할 수록 내용은 더더욱 어렵다..
 - 뭐든 하나 하나 풀어보고 이해하며, 복습하자. 한번 풀었다고 자다깨도 풀 수 있는게 아니다.