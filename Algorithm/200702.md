## 알고리즘 - 팰린드롬??(해시)

 1. 해시로 나타내려는 숫자나 문자의 개수 + 1의 진수값으로 나타낼 줄 알것.

 2. 해시값이 같더라도 다른 문자가 나올 수 있다. 그러므로, pair<ll, ll>꼴로 만들되 모듈러 값을 두개를 만들어, 해시값을 두개 가진 변수로 운영을 한 후, 같은지 판정을 할 때 **두개의 해시값이 모두 같아야 같은 것으로 판정**을 해야 한다.

 3. 해시값을 계산하는 배열 h[0] = 0이고, 제곱값 저장하는 배열 p[0] = 1이다.

 4. 모듈러 연산 선언법. D1 = (1ll<< 30), D2 = 1e9 + 7로 하자.

 5. h[j:i+1] = h[i] - h[j-1]*26^(i-j+1) 이거 외워야 하는건지..

 6. 5번 경우는 내림차순으로 해시를 구성한 경우 사용해야 하고, 오름차순일 경우에는 그냥 빼주면 된다. 하지만, 나눗셈의 문제가 생길 수 있다.
 
## 알고리즘 - Neko Finds Grapes(Codeforces)

 - 상자와 키가 있고 상자와 키는 각자 고유의 값이 존재함

 - 상자와 키의 합은 반드시 홀수여야만 매칭 가능하며, 매칭 가능한 최대 길이를 구하는 문제

 - https://codeforces.com/contest/1152/problem/A

 - n이 10^5이므로 O(n^2) 풀이 불가능.

 - 더해서 홀수가 나오려면 (홀 + 짝) or (짝 + 홀) 이다. 이중 작은 값 만큼 매칭될 것이니 출력해주면 됨.

## 알고리즘 - Journey Planning

 - 소팅 + dp를 쓰는 문제인데 수열에서 dp를 어떻게 쓰는지 모르겠다. 약점을 잘 짚어준 좋은 문제. 나중에 풀이법 보면 반드시 익히고 관련 문제 연습할 것!

 - https://codeforces.com/contest/1321/problem/B


## 알고리즘 - Puyo Puyo

 - 도미노 문제의 시초였네 하 진작 풀어볼걸..

 - bfs 한 결과가 4개 이상이면 해당 obj는 소멸되고, 테트리스처럼 **소멸된 obj의 윗쪽 라인부터 내려오게 하는 로직 짜는게 중요**

 - Q1. 뿌요가 된 시점부터 위로 탐색을 했어야 하는가?

 - Q2. 블록이 내려올때 (바닥까지 내려오는 조건 + 다른 블록까지 내려오는 조건) 이걸 좀더 깔끔하게 짤 수 있는 방법을 확실히 알고 있는가?

 - A. 도미노 코드 다시 보자.. 알고있다고 생각하지만 모른다.

## 20. 07. 02(목)
 - 해시 계산 논리 반드시 식으로 써보고 확실히 익힐것
 - 코포 열릴때마다 문제라도 보자 흥미로운거 많다.