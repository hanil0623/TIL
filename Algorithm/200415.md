## 알고리즘 - 다익스트라 재정리

 - 몇번째 봐도 알기 힘든 다익스트라 재정리.
 
 - 준비물 : priority_queue, dist 배열(fill(INF))

 ```
 priority_queue< -weight, 목적지 vertex number>
 
 dist[시작 vertex] = 0;

 pq.push({0, 시작 number});

 while(!pq.empty()){
     int 내 vertex = pq.front().second;
     int weight = -pq.front().first;

     for( 큐에서 꺼낸 나의 vertex → 다음 목적지를 나타냄){
         if(다음 목적지의 제한조건 처리) continue;

         int neighborDist = weight + 다음 목적지의 weight;

         if(dist[다음목적지] > neighborDist){
             dist[다음목적지] = neighborDist;
             pq.push({-neighborDist, 다음목적지});
         }
         
     }
 }
 return dist[목적지번호];
 ```

 - ***다익스트라의 시간복잡도***

 - 우선순위큐를 사용한 삽입, 삭제 시간은 (O(logE))이다.
 - 우선순위큐에 들어갈 수 있는 최대 점의 수는 O(E)이다.
 - 다익스트라 진행 과정
    : 1. 시작점에서 연결된 모든 E에 대해 dist 배열 갱신(pq에 삽입)
     pq에 삽입하는 시간이 logE 이기 때문에 ElogE가 됨.
    
    = 각 정점마다 인접한 간선들을 모두 검사하는 작업(E)

    = 우선순위 큐에 원소를 넣고 삭제하는 작업(logE)

    = 어떤 점에서 연결된 Edge끼리 비교 * 갱신(큐 삽입)(logE) 반복이잖아.

    = 근데 이 작업을 V까지 한번만 돌리거든?

    여튼 다익스트라는 각 Edge 마다 검사하여 우선순위큐에 넣는 작업(logE) 합쳐서 O(ElogE)가 걸린다는 사실만 알아두자.

    




## 알고리즘 - 배열 돌리기 4(Review)
 - 특정 지점을 기준으로 배열을 돌리는 로직에서 중요한 점.
 - 1. 중심점과 끝 범위 값을 반드시 활용한다.
 - 2. 반드시 임시 배열을 사용하여 옮긴다.

 ```
 for(4방향){
     while(1){
         nx, ny 정의
         if(배열 돌리는 범위 조건){ break;}
         temp_map[nx][ny] = map[x][y];
         x = nx;
         y = ny;
     }
 }
 ```
 

 ## 알고리즘 - 구슬 탈출 2 (2)

  1. Object가 두개 동시에 움직이는데 어떻게 컨트롤 해야 했냐?

  2. 1칸 nx, ny 움직이는 것이 아니라 while문으로 끝까지 움직이는 경우 컨트롤법(벽 만나기 전까지)

  3. 2개의 Object가 Flow 형식을 띠고 있을 때 어떻게 처리를 해야 할지?

  - 교훈 1. 움직이는 Object가 두 개 이상이면 해당 object 만큼 차원의 배열을 만들어서 표시해 준다.

  - 교훈 2. Flow 과녁이 있고 해당 Object가 있다면 ***무조건 예외처리의 경우의 수***를 생각해라.

   : R→O, B !→ O == True
   : R→O, B→ O == False
   : R!→O, B → O == False
   : R !→O, B !→ O == 움직일 수 있다.
   : 그러니까, for(4방향) 이부분 부터는 움직이는 시뮬레이션이니까, 위 조건들을 모두 따져서 움직일 수 있는지 아닌지 코딩하기 전에 위 조건들을 조목조목 따져서 판단해 보길 바란다.

   : 즉, Flow의 화살 Object간 조건이 있는 경우였지. 나중에 한번 더 풀어봐도 좋은 문제이다.

   - 교훈 3. Object를 두개 동시에 컨트롤 할 때, 먼저 겹치게 만들어 놓고, 겹치게 된다면 cur -> next 간 dist 값을 비교해 보고 더 많이 움직인 쪽을 반대로 움직여라!
   : 반대로 움직이는 테크닉이 신기했다.
     nx = x + dx[i] (정방향 움직이기)
     nx = x - dx[i] (반대로 움직이기)

 - 교훈 3. DFS로 풀어도 되긴 하는데, BFS로 푸는 것이 나은 이유는, 일단 움직이는 Object가 두개이상 관리를 해야 한다면 DFS같더라도 BFS를 고려해보자.

 
## 20. 04. 15(수)
 - 알고있던 것을 다시 복습하는거 되게 중요하다..
 - 다익스트라, 배열 돌리기 다시 연습연습 연습!!
 - 복습만이 살길이다.