## 알고리즘 - 다익스트라 재정리

 - 몇번째 봐도 알기 힘든 다익스트라 재정리.
 
 - 준비물 : priority_queue, dist 배열(fill(INF))

 ```
 priority_queue< -weight, 목적지 vertex number>
 
 dist[시작 vertex] = 0;

 pq.push({0, 시작 number});

 while(!pq.empty()){
     int 내 vertex = pq.front().second;
     int weight = -pq.front().first;

     for( 큐에서 꺼낸 나의 vertex → 다음 목적지를 나타냄){
         if(다음 목적지의 제한조건 처리) continue;

         int neighborDist = weight + 다음 목적지의 weight;

         if(dist[다음목적지] > neighborDist){
             dist[다음목적지] = neighborDist;
             pq.push({-neighborDist, 다음목적지});
         }
         
     }
 }
 return dist[목적지번호];
 ```

 - ***다익스트라의 시간복잡도***

 - 우선순위큐를 사용한 삽입, 삭제 시간은 (O(logE))이다.
 - 우선순위큐에 들어갈 수 있는 최대 점의 수는 O(E)이다.
 - 다익스트라 진행 과정
    : 1. 시작점에서 연결된 모든 E에 대해 dist 배열 갱신(pq에 삽입)
     pq에 삽입하는 시간이 logE 이기 때문에 ElogE가 됨.
    
    = 각 정점마다 인접한 간선들을 모두 검사하는 작업(E)

    = 우선순위 큐에 원소를 넣고 삭제하는 작업(logE)

    = 어떤 점에서 연결된 Edge끼리 비교 * 갱신(큐 삽입)(logE) 반복이잖아.

    = 근데 이 작업을 V까지 한번만 돌리거든?

    여튼 다익스트라는 각 Edge 마다 검사하여 우선순위큐에 넣는 작업(logE) 합쳐서 O(ElogE)가 걸린다는 사실만 알아두자.

    




## 알고리즘 - 배열 돌리기 4(Review)
 - 특정 지점을 기준으로 배열을 돌리는 로직에서 중요한 점.
 - 1. 중심점과 끝 범위 값을 반드시 활용한다.
 - 2. 반드시 임시 배열을 사용하여 옮긴다.

 ```
 for(4방향){
     while(1){
         nx, ny 정의
         if(배열 돌리는 범위 조건){ break;}
         temp_map[nx][ny] = map[x][y];
         x = nx;
         y = ny;
     }
 }
 ```
 
## 20. 04. 15(수)
 - 알고있던 것을 다시 복습하는거 되게 중요하다..
 - 다익스트라, 배열 돌리기 다시 연습연습 연습!!
 - 복습만이 살길이다.