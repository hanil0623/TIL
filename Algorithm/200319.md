## 알고리즘 - 원자 소멸 시뮬레이션
 - 어떤 Object가 방향을 가지고 움직인다 = 3~4방향에서 한번에 모이는 경우가 없는가?

 - 원자가 한 공간에 존재하게 될 때, 합쳐지는가? 소멸되는가? 에 따라 처리방법이 다르다.

    1. **소멸**된다? + map의 경곗값이 있다 = ***경곗값을 넘어가면 원자가 소멸함***을 반드시 처리해라.

    ```
    if(map[x][y] >= 2) // 한 공간에 원자가 두 개 이상일 경우
    {
        // vsize 만큼 돌면서 원자가 소멸하기 전 시뮬레이션을 한 다음 소멸시킨다.
        for(int i=0; i<v.size(); i++){
            if(v[i].x == x && v[i].y == y){
                v[i].energy = 0;
            }
        }
        map[x][y] = 0 // 원자 소멸
    }
    ```

    2. 합쳐진다?
    - 이 부분도 위와 마찬가지로 내부 for문을 돌면서 실행해도 된다.
    - map의 사이즈가 작은 경우에는 1 time 당 다음 위치에 있을 Object의 맵들을 구성하고 기존의 map → next_map으로 옮겨가며
    진행해도 된다. (여기서는 배열의 type을 struct로 선언하는 편 : node map[n][n])
    단, 1 time 당 O(N^2)이 들기 때문에 N의 사이즈를 잘 판단하고 해야 겠다.
    두 가지 방법 중 편한 대로 사용하는 것이 좋다.

 - 시간에 관한 관점인데 어떤 행동을 할 때 몇 초에 이 행동이 완료될 것인지 반드시 꼼꼼히 체킹해 보자. 이 습관을 제대로 들여야 한다.

 - 이 문제에서 가장 고민했던 부분은 *** 기존 코딩을 할 때의 좌표 체계와 문제에서 input으로 준 좌표 체계 ***가 다르다는 점이였다.
   문제 : x가 가로, y가 세로인 좌표체계
   사용 : x가 세로, y가 가로인 좌표체계.
   이 체계 간의 싱크를 맞추기 위해서는 반드시 종이에 그려보고 간단한 input 값을 준 후에 행동할 것.


## 20. 03. 19 (목)
 - 두번 보니까 내 코드가 아닌 것들이 내 코드가 되어 가는 느낌을 받는다. 계속 하자
