## 알고리즘 - 텀 프로젝트
 - 이 문제는 사이클을 이루고 있는 집합과 그렇지 않은 집합을 분리하여 생각하되,
   각 정점마다 dfs를 돌려 사이클을 찾는 방법을 쓴다면 O(V(V+E))로 TLE 발생을 할 수 있다.(노드가 10만개)
 - 그래서 사이클의 여부는 dfs 트리 한 번으로 찾을 수 있으며,
   단방향일 경우와 양방향일 경우가 다르게 적용된다.
   먼저 단방향일 경우, **서브스패닝트리의 루트**에 도달할 수 있으면 다시 루트부터 내려갈 수 있기 때문에 사이클이 생긴다.

 - 클론 코딩을 하면서 알아야 할 포인트는 두가지이다.
 ```
 int dfs(int i){
     if(visit[i]) // sub-spanning tree 에서의 사이클 발생 여부를 체킹하기 위함.
        return i; // 임시용
     if(check[i]) // 전체 node 방문 여부를 체킹하기위한 것.(영구)
        return 0;
     visit[i] = 1;
     check[i] = 1;
     int next = dfs(v[i]); 
     // 여기까지만 하면 사이클이 발생한다면 스패닝트리의 루트노드가 나오게 됨.
     // 사이클이 발생하지 않는다면 check에서 걸려, 0의 값이 나오게 된다.
     // 1. 사이클이 발생하는 조건을 나타내는 코드를 쉽게 작성 할 수 있는가?
     visit[i] = 0; // 사이클이 발생하는 루트노드를 알았기에 원상복귀처리(prev)
     if(next > 0){ // 사이클이 발생한다면?
        ans[i] = 1; // 사이클이 발생하는 sub-spanning tree의 노드를 입력해주고
        if(next != i){
            return next; 
            // 2. SST의 세부 노드요소들을 리턴하는데, 루트까지 리턴하기 위함이다.
            // 루트로부터 자식까지 갔다가 루트와 같게되면 리턴 0을 처리함.
        }

     }
     return 0;
 }
 ```
 이후 ans = 0인 i만 찾아주면 사이클이 발생하지 않는 graph 요소들을 모두 알 수 있다.

## 20. 02. 21(금)
 - 감탄스러운 코드이다. 얼마나 잘 이해하고 있으면 이런 코드를 작성할 수 있을까?