## 알고리즘 - 구간 성분

 - 실제 해시값을 구할 때 주의해야 하는 팁 몇가지 정리

   1. 문자를 받을 땐 인덱스에 헷갈리지 않게 a[1]부터 input을 받자.(a[0] == '\0')

   2. 전처리를 할 때 a^n 값을 미리 저장하는 방식을 쓰자.

      ```
      for(int i=1; i<26; i++){
          // 반드시 오버플로 막기 위한 Modular 연산 하자.
          p[i] = p[i-1] * 1501 % D;
      }
      ```

   3. 이후, 1 ~ i까지 구간 정보 해시값을 저장한 배열을 만들자.

      ```
      for(int i=1; i<=n; i++){
          aa[i] = (aa[i-1] + c[a[i] - 'a']) % D;
      }
      ```

   4. 해당하는 해시값이 존재하는지 여부는 보통 set을 사용하는 편이다.

      ```
      for(i=k; i<=n; i++)
        // k = 1이라면 [1]의 구간 해시값, [2], [3] ... [n]까지 값을 s에 넣는다.
        // 단, 해시값을 빼는 작업은 마이너스값이 될 경우 오류가 날 수 있으므로
        // 반드시 Modular 값을 더해주자.
        s.insert(aa[i] - aa[i-k] + D) % D);
    
      for(i=k; i<=m; i++)
        // pattern 문자를 보며 만약 b[1]에 해당하는 구간값이 aa[1] ... aa[n] 안에 있다면 리턴을 해준다.
        if(s.count((bb[i] - bb[i-k] + D) % D)) return 1;
      ```

   5. 두개의 문자열 길이 na, nb 중 짧은 길이의 값까지 for문을 돌고싶을 때는
      for(int i=1; i<=n && i<=m; i++)와 같이 쉽게 할 수 있다.

## 20. 07. 01(수)
 - set을 사용할 수 없을 경우 어떻게 확인하는지 물어봐야한다.
