## 알고리즘 - 막대기(dp)

 - Catch : 두개의 수평선이 있고 이를 잇는 행위에 대한 dp를 어떻게 구상하고 어떤 state의 변화로 캐치하는지 아는 것.

 - Solve : 
   + dp1[i] : 위쪽 수평선의 i까지 잇는 선 중 조건을 만족하는 지그재그 길이
   + dp2[i] : 아래쪽 수평선의 i까지 잇는 선 중 조건을 만족하는 지그재그 길이

```
 1. (i,j)를 pair로 잡아 i를 기준으로 오름차순 sort를 한다.

 2. dp1[x] = y까지 이은 지그재그의 길이(dp2[y]) + x,y를 잇는 길이 |a-b| + L의 최댓값

 3. dp2[y] = x까지 이은 지그재그의 길이(dp1[x]) + |a-b|+L의 최댓값.

 단, 2번에서 계산한 값이 3번에 적용되면 안되므로 for문 시작 전 변수화를 꼭 시켜주자.

 4. dp1과 dp2중 max값이 답이다.
 ```

#### Map을 활용한 좌표압축법 :star:

 - 1. x좌표 전용, y좌표 전용 맵을 두개 선언한다. (m1, m2)

 - 2. 좌표를 받으면서 
 
    - if(!m1[x좌표]) m1[x좌표] = ++k; (idx)
    - if(!m2[y좌표]) m2[y좌표] = ++c; (idx, 좌표 압축)

 - 3. 참조할 땐 dp[m1[x좌표]] 와 같이 할 수 있다.!

## 20. 09. 01(화)
 - 핵심 키워드 중심으로 CS 공부 + 알고리즘 병행. CS 시간 꼭 채우자.


 